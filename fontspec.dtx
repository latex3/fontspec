% \iffalse
%<*internal>
\begingroup
\input docstrip.tex
\keepsilent
\usedir{tex/latex/fontspec}
\let\MetaPrefix\relax
\preamble

  _________________________________________
  The fontspec package for XeLaTeX/LuaLaTeX
  (C) 2004--2010    Will Robertson and Khaled Hosny

  License information appended.


\endpreamble
\postamble

Copyright 2004--2010 Will Robertson <wspr81@gmail.com>
Copyright 2009--2010 Khaled Hosny <khaledhosny@eglug.org>

Distributable under the LaTeX Project Public License,
version 1.3c or higher (your choice). The latest version of
this license is at: http://www.latex-project.org/lppl.txt

This work is "author-maintained" by Will Robertson.

This work consists of this file fontspec.dtx
          and the derived files fontspec.sty,
                                fontspec.lua,
                                fontspec.cfg,
                                fontspec-xetex.tex,
                                fontspec-luatex.tex,
                            and fontspec.pdf.

\endpostamble
\askforoverwritefalse

\def\MetaPrefix{-- }
\generate{\file{fontspec.lua}          {\from{fontspec.dtx}{lua}}}

\let\MetaPrefix\DoubleperCent
\generate{\file{fontspec.sty}          {\from{fontspec.dtx}{fontspec}}}
\generate{\file{fontspec-patches.sty}  {\from{fontspec.dtx}{patches}}}
\generate{\file{fontspec-testsuite.tex}{\from{fontspec.dtx}{testsuite}}}

\nopreamble\nopostamble
\generate{\file{fontspec.cfg}          {\from{fontspec.dtx}{cfg}}}
\generate{\file{fontspec-example.tex}  {\from{fontspec.dtx}{example}}}

\def\tmpa{plain}
\ifx\tmpa\fmtname\endgroup\expandafter\bye\fi

\generate{\file{fontspec-style.sty}    {\from{fontspec.dtx}{doc-style}}}
\endgroup
%</internal>
%
%<*driver>
\ProvidesFile{fontspec.dtx}
%</driver>
%<fontspec>\ProvidesPackage{fontspec}
%<patches>\ProvidesPackage{fontspec-patches}
%<*fontspec|patches>
  [2010/10/13 v2.1c Advanced font selection for XeLaTeX/LuaLaTeX]
%</fontspec|patches>
%
%<*driver>
\documentclass[a4paper]{ltxdoc}
\usepackage{fontspec-style}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
%\OnlyDescription
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
%
% \fi
%
% \GetFileInfo{fontspec.dtx}
% \makeatletter                         ^^A% To document @-cmds
% \errorcontextlines=999                ^^A% Show up all my mistakes
%
% \title{The \textsf{fontspec} package}
% \author{
%    \textsc{Will Robertson} and \textsc{Khaled Hosny}\\
%    \texttt{will.robertson@latex-project.org}
% }
% \date{\filedate \qquad \fileversion}
%
% \maketitle
% \tableofcontents
%
% \section{History}
%
% This package began life as a \LaTeX\ interface to select system-installed
% \MacOSX\ fonts in \name{Jonathan Kew}'s \XeTeX, the first widely-used
% Unicode extension to \TeX. Over time, \XeTeX\ was extended to support OpenType
% fonts and then was ported into a cross-platform program to run also on Windows
% and Linux.
%
% More recently, \LuaTeX\ is fast becoming the \TeX\ engine of the day; it
% supports Unicode encodings and OpenType fonts and opens up the internals of
% \TeX\ via the Lua programming language. Hans Hagen's Con\TeX t Mk.\,IV is a
% re-write of his powerful typesetting system, taking full advantage of
% \LuaTeX's features including font support; a kernel of his work in this area
% has been extracted to be useful for other \TeX\ macro systems as well, and
% this has enabled \pkg{fontspec} to be adapted for \LaTeX\ when run with the
% \LuaTeX\ engine. Elie Roux and Khaled Hosny have been instrumental and
% invaluable with this development work.
%
% \section{Introduction}
%
% The \pkg{fontspec} package allows users of either \XeTeX\ or \LuaTeX\ to
% load OpenType fonts in a \LaTeX\ document. No font installation is necessary,
% and font features can be selected and used as desired throughout the document.
%
% Without \pkg{fontspec}, it is necessary to write cumbersome font definition
% files for \LaTeX, since \LaTeX's font selection scheme (known as the
% `\textsc{nfss}') has a lot going on behind the scenes to allow easy
% commands like \cmd\emph\ or \cmd\bfseries. With an uncountable number of
% fonts now available for use, however, it becomes less desirable to have to
% write these font definition (|.fd|) files for every font one wishes to use.
%
% Because \pkg{fontspec} is designed to work in a variety of modes, this
% user documentation is split into separate sections that are designed to be
% relatively independent. Nonetheless, the basic functionality all behaves in
% the same way, so previous users of \pkg{fontspec} under \XeTeX\ should have
% little or no difficulty switching over to \LuaTeX.
%
% This manual can get rather in-depth, as there are a lot of details
% to cover. See the example documents \path{fontspec-xetex.tex} and
% \path{fontspec-luatex.tex} for a complete minimal example with each engine.
%
% \subsection{About this manual}
%
% This document is typeset with pdf\LaTeX\ using pre-compiled examples
% that have been generated by either \XeTeX\ or \LuaTeX. You may regenerate
% the examples by removing the \verb|doc/| subdirectory and typesetting the
% manual with the following invocation:
% \begin{verbatim}
%   pdflatex -shell-escape fontspec.dtx
% \end{verbatim}
% Note that many of the examples use fonts that are not included in \TeX~Live
% or MiKTeX, and some of them are non-free fonts that must be purchased.
%
% I'd like to reduce the number of non-free fonts used in this
% manual. If you know any freely available fonts that could be used
% as alternative to any of the fonts in this document, please suggest them
% to me.
% Finally, if any aspect of the documentation is unclear or you would
% like to suggest more examples that could be made, get in touch.
% (Contributions especially welcome.)
%
% \subsection{Acknowledgements}
%
% This package couldn't be possible without the early and continued support
% the author of \XeTeX, Jonathan Kew. When I started this package, he steered
% me many times in the right direction.
%
% I've had great
% feedback over the years on feature requests, documentation queries, bug reports, font suggestions, and so on from lots of people all around the world.
% Many thanks to you all.
%
% Thanks to David Perry for numerous documentation improvements and
% contributing the text for one of the sections of this manual.
%
% Special thanks to Khaled Hosny, who had been the driving force behind the support for \LuaLaTeX, ultimately leading to version 2.0 of the package.
%
% \section{Package loading and options}
%
% For basic use, no package options are required:
% \begin{Verbatim}
%   \usepackage{fontspec}
% \end{Verbatim}
%
% \paragraph{\pkg{xunicode}}
% Ross Moore's \pkg{xunicode} package is now automatically loaded for
% users of both \XeLaTeX\ and \LuaLaTeX.
% This package provides backwards compatibility with \LaTeX's methods for accessing extra
% characters and accents (for example, |\%|, |\$|, |\textbullet|, |\"u|, and
% so on), plus many more Unicode characters.
% \textbf{Warning}: introduced in v2.1, this is a backwards incompatible change to previous
% versions of \pkg{fontspec}. This change was necessary in order to provide consistent
% support for users of \XeTeX\ and \LuaTeX. I'm not aware of any issues this
% may cause but please let me know if you run into problems.
%
% \paragraph{\XeTeX\ users only}
% The \pkg{xltxtra} package adds some minor extra features to \XeLaTeX, including, via the \pkg{metalogo} package, the
% \cmd\XeTeX\ macro to typeset the \XeTeX\ logo. While this package was
% previously recommended, it serves a much smaller r\^ole nowadays and generally
% will not be required.
%
% \paragraph{\LuaTeX\ users only}
% In order to load fonts by their name rather than by their filename (\eg,
% `Latin Modern Roman' instead of `ec-lmr10'), you may need to run the script
% \texttt{mkluatexfontdb}, which is distributed with the \pkg{luaotfload}
% package. Note that if you do not execute this script beforehand, the first
% time you attempt to typeset the process will pause for (up to) several
% minutes. (But only the first time.)
% Please see the \pkg{luaotfload} documentation for more information.
%
% \paragraph{\pkg{babel}}
% \emph{The \pkg{babel} package is not really supported!} Especially Vietnamese,
% Greek, and Hebrew at least might not work correctly, as far as I can tell.
% There's a better chance with Cyrillic and Latin-based languages,
% however---\pkg{fontspec} ensures at least that fonts should load correctly,
% but hyphenation and other matters aren't guaranteed. Under \XeTeX, the
% \pkg{polyglossia} package is recommended instead as a modern replacement for
% \pkg{babel}.
%
%
%
% \subsection{Maths fonts adjustments}
% By default, \pkg{fontspec} adjusts \LaTeX's
% default maths setup in order to maintain the correct Computer Modern symbols
% when the roman font changes. However, it will attempt to avoid doing this if
% another maths font package is loaded (such as \pkg{mathpazo} or the
% \pkg{unicode-math} package).
%
% If you find that \pkg{fontspec} is incorrectly changing the maths font when it should be
% leaving well enough alone, apply the |[no-math]| package option to manually
% suppress its maths font.
%
% \subsection{Configuration} If you wish to customise any part of the
% \pkg{fontspec} interface (see later in this manual, \vref{sec:newfeatures}
% and~\ref{sec:aliasfontfeature}), this should be done by creating your own
% \texttt{fontspec.cfg} file,
% which will be automatically loaded if it is found by \XeTeX\ or \LuaTeX. Either place it
% in the same folder as the main document for isolated cases, or in a location
% that \XeTeX\ or \LuaTeX\ searches by default; \eg\ in Mac\TeX: \path{~/Library/texmf/tex/latex/}.
% The package option |[no-config]| will suppress this behaviour under all circumstances.
%
% \subsection{Warnings}
% \label{sec:quiet-warnings}
%
% This package can give many warnings that can be harmless if you know what
% you're doing. Use the |[quiet]| package option to write these warnings to the
% transcript (\texttt{.log}) file instead.
%
% Use the |[silent]| package option to completely suppress these warnings if you
% don't even want the |.log| file cluttered up.
%
%
%
%
%
% \part{General font selection}
%
% This section concerns the variety of commands that can be used to select
% fonts.
%
% \cmdbox{%
%   \CMD{\string\fontspec} \oarg{font features} \marg{font name}\\
%   \CMD{\string\setmainfont} \oarg{font features} \marg{font name}\\
%   \CMD{\string\setsansfont} \oarg{font features} \marg{font name}\\
%   \CMD{\string\setmonofont} \oarg{font features} \marg{font name}\\
%   \CMD{\string\newfontfamily} \meta{cmd} \oarg{font features} \marg{font name}
% }
%
% These are the main font-selecting commands of this package.
% The \cs{fontspec} command selects a font for one-time use; all
% others should be used to define the standard fonts used in a document.
% They will be described later in this section.
%
% The font features argument accepts comma separated
% \meta{font feature}=\meta{option} lists; these are described in later:
% \begin{itemize}
% \item For general font features, see \vref{sec:font-ind-features}
% \item For OpenType fonts, see Part~\vref{sec:opentype-features}
% \item For \XeTeX-only general font features, see Part~\vref{sec:xetex-features}
% \item For \LuaTeX-only general font features, see Part~\vref{sec:luatex-features}
% \item For features for \AAT\ fonts in \XeTeX, see \vref{sec:aat-features}
% \end{itemize}
%
% \section{Font selection}
%
% In both \LuaTeX\ and \XeTeX, fonts can be selected either by `font name' or
% by `file name'.
%
% \subsection{By font name}
%
% Fonts known to \LuaTeX\ or \XeTeX\ may be loaded by their names.
% `Known to' in this case generally means `exists in a standard fonts location'
% such as |~/Library/Fonts| on \MacOSX, or |C:\Windows\Fonts| on Windows.
%
% The simplest example might be something like
% \begin{Verbatim}
%   \fontspec[ ... ]{Cambria}
% \end{Verbatim}
% in which the bold and italic fonts will be found automatically
% (if they exist) and are immediately accessible with the usual
% \cs{textit} and \cs{textbf} commands.
%
% TODO: add explanation for how to find out what the `font name' is.
%
%
% \subsection{By file name}
% \label{sec:by-file-name}
%
% \XeTeX\ and \LuaTeX\ also allow fonts to be loaded by file name instead of font name.
% When you have a very large collection of fonts, you will sometimes not
% wish to have them all installed in your system's font directories.
% In this case, it is more convenient to load them from a different location on your disk.
% This technique is also necessary in \XeTeX\ when loading OpenType fonts that are present within your \TeX\ distribution, such as \path{/usr/local/texlive/2010/texmf-dist/fonts/opentype/public}.
% Fonts in such locations are visible to \XeTeX\ but cannot be loaded by font name, only file name; \LuaTeX\ does not have this restriction.
%
% When selecting fonts by file name, any font that can be found in the default
% search paths may be used directly (including in the current directory)
% without having to explicitly define the location of the font file on disk.
%
% \paragraph{\XeTeX\ \& Mac users only:}
% Note that \XeTeX\ can only select fonts in this way with the |xdvipdfmx| driver, but \XeTeX\ with the |xdv2pdf| driver can only select system-installed fonts
% by font name and not file name. The |xdvipdfmx| driver is default for \XeTeX, so this is only a problem if you wish to explicitly use
% the |xdv2pdf| driver.
%
% Fonts selected by filename must include bold and italic variants explicitly.
% \begin{Verbatim}
%   \fontspec
%      [ BoldFont       = texgyrepagella-bold.otf ,
%        ItalicFont     = texgyrepagella-italic.otf ,
%        BoldItalicFont = texgyrepagella-bolditalic.otf ]
%      {texgyrepagella-regular.otf}
% \end{Verbatim}
% \pkg{fontspec} knows that the font is to be selected by file name by the
% presence of the `|.otf|' extension.
% An alternative is to specify the extension separately, as shown following:
% \begin{Verbatim}
%   \fontspec
%      [ Extension      = .otf ,
%        BoldFont       = texgyrepagella-bold ,
%        ... ]
%      {texgyrepagella-regular}
% \end{Verbatim}
% If desired, an abbreviation can be applied to the font names based on the
% mandatory `font name' argument:
% \begin{Verbatim}
%   \fontspec
%      [ Extension      = .otf ,
%        UprightFont    = *-regular ,
%        BoldFont       = *-bold ,
%        ... ]
%      {texgyrepagella}
% \end{Verbatim}
% In this case `texgyrepagella' is no longer the name of an actual font,
% but is used to construct the font names for each shape;
% the |*| is replaced by `texgyrepagella'.
% Note in this case that |UprightFont| is required for constructing the font
% name of the normal font to use.
%
% To load a font that is not in one of the default search paths, its location
% in the filesystem must be specified with the |Path| feature:
% \begin{Verbatim}
%   \fontspec
%      [ Path           = /Users/will/Fonts/ ,
%        UprightFont    = *-regular ,
%        BoldFont       = *-bold ,
%        ... ]
%      {texgyrepagella}
% \end{Verbatim}
% Note that \XeTeX\ and \LuaTeX\ are able to load the font without giving an
% extension, but \pkg{fontspec} must know to search for the file; this can can
% be indicated by declaring the font exists in an `|ExternalLocation|':
% \begin{Verbatim}
%   \fontspec
%      [ ExternalLocation ,
%        BoldFont       = texgyrepagella-bold ,
%        ... ]
%      {texgyrepagella-regular}
% \end{Verbatim}
% To be honest, |Path| and |ExternalLocation| are actually the same feature
% with different names. The former can be given without an argument and the
% latter can be given with one; the different names are just for clarity.
%
%
% \section{Default font families}
% \label{sec:setxxfont}
%
% \cmdbox{
%   \cmd{\setmainfont} \oarg{font features} \marg{font name} \\
%   \cmd{\setsansfont} \oarg{font features} \marg{font name} \\
%   \cmd{\setmonofont} \oarg{font features} \marg{font name}
% }
%
% These commands are used to select
% the default font families for the entire document. They take the
% same arguments as \cmd{\fontspec}. See \exref{fontload}.
% Here, the scales of the fonts have been chosen to equalise their
% lowercase letter heights. The \feat{Scale} font feature will be discussed
% further in \vref{sec:font-ind-features}, including methods for automatic
% scaling.
%
% \begin{Lexample}{fontload}{Loading the default, sans serif, and monospaced fonts.}
%   \setmainfont{TeX Gyre Bonum}
%   \setsansfont[Scale=MatchLowercase]{Latin Modern Sans}
%   \setmonofont[Scale=MatchLowercase]{Inconsolata}
%
%   \rmfamily Pack my box with five dozen liquor jugs\par
%   \sffamily Pack my box with five dozen liquor jugs\par
%   \ttfamily Pack my box with five dozen liquor jugs
% \end{Lexample}
%
%
%
%
% \section{New commands to select font families}
%
% \cmdbox{
%   \CMD{\string\newfontfamily} \cs{\meta{font-switch}} \oarg{font features} \marg{font name} \\
%   \CMD{\string\newfontface} \cs{\meta{font-switch}} \oarg{font features} \marg{font name}
% }
%
% \noindent For cases when a specific font with a specific
% feature set is going to be re-used many times in a document, it is inefficient
% to keep calling \cs{fontspec} for every use. While the \cs{fontspec} command does not define
% a new font instance after the first call, the feature options must still be
% parsed and processed.
%
% \DescribeMacro{\newfontfamily}
% For this reason, new commands can be created for loading a particular font
% family with the \cmd\newfontfamily\ command, demonstrated in \exref{nff}.
% This macro should be used to create commands that would be used in
% the same way as \cmd\rmfamily, for example.
% If you would like to create a command that only changes the font
% inside its argument (i.e., the same behaviour as \cs{emph}) define it using regular \LaTeX\
% commands:
% \begin{Verbatim}
%   \newcommand\textnote[1]{{\notefont #1}}
%   \textnote{This is a note.}
% \end{Verbatim}
% Note that the double braces are intentional; the inner pair are used to
% to delimit the scope of the font change.
%
% \begin{Lexample}{nff}{Defining new font families.}
%   \newfontfamily\notefont{Kurier}
%   \notefont This is a \emph{note}.
% \end{Lexample}
%
% \DescribeMacro{\newfontface}
% Sometimes only a specific font face is desired, without accompanying italic or bold variants
% being automatically selected.
% This is common when selecting a fancy italic font, say, that has swash features unavailable
% in the upright forms. \cmd\newfontface\ is used for this purpose, shown
% in \exref{nfface}, which is repeated in \vref{sec:contextuals}.
%
% \begin{Xexample}{nfface}{Defining a single font face.}
%   \newfontface\fancy
%       [Contextuals={WordInitial,WordFinal}]
%                        {Hoefler Text Italic}
%   \fancy where is all the vegemite
%   % \emph, \textbf, etc., all don't work
% \end{Xexample}
%
% Comment for advanced users:
% The commands defined by \cs{newfontface} and \cs{newfontfamily} include
% their encoding information, so even if the document is set to use a
% legacy \TeX\ encoding, such commands will still work correctly. For example,
% \begin{verbatim}
% \documentclass{article}
% \usepackage{fontspec}
% \newfontfamily\unicodefont{Lucida Grande}
% \usepackage{mathpazo}
% \usepackage[T1]{fontenc}
% \begin{document}
% A legacy \TeX\ font. {\unicodefont A unicode font.}
% \end{document}
% \end{verbatim}
%
% \subsection{More control over font shape selection}
% \label{sec:bfitfonts}
%
% \cmdbox{
%  \feat{BoldFont} = \meta{font name} \\
%  \feat{ItalicFont} = \meta{font name} \\
%  \feat{~BoldItalicFont} = \meta{font name} \\
%  \feat{SlantedFont} = \meta{font name} \\
%  \feat{BoldSlantedFont} = \meta{font name} \\
%  \feat{SmallCapsFont} = \meta{font name}
% }
%
% The automatic bold, italic, and bold italic font selections will not be
% adequate for the needs of every font: while some fonts mayn't even
% have bold or italic shapes, in which case a skilled (or lucky)
% designer may be able to chose well-matching accompanying shapes from
% a different font altogether, others can have a range of bold and
% italic fonts to chose among.  The \feat{BoldFont} and
% \feat{ItalicFont} features are provided for these situations. If only
% one of these is used, the bold italic font is requested as the
% default from the \emph{new} font. See \exref{bff}.
%
% \begin{Xexample}{bff}{Explicit selection of the bold font.}
%   \fontspec[BoldFont={Helvetica Neue}]
%                           {Helvetica Neue UltraLight}
%                 Helvetica Neue UltraLight         \\
%   {\itshape     Helvetica Neue UltraLight Italic} \\
%   {\bfseries               Helvetica Neue       } \\
%   {\bfseries\itshape       Helvetica Neue Italic} \\
% \end{Xexample}
%
% If a bold italic shape is not defined, or you want to specify
% \emph{both} custom bold and italic shapes, the \feat{BoldItalicFont}
% feature is provided.
%
% \subsubsection{Input shorthands}
%
% For those cases that the base font name is repeated, you can
% replace it with an asterisk. (This has been shown previously in \vref{sec:by-file-name}.)
% For example,
% some space can be saved instead of writing `\texttt{Baskerville SemiBold}':
% \begin{Verbatim}
%   \fontspec[BoldFont={* SemiBold}]{Baskerville}
% \end{Verbatim}
%
% As a matter of fact, this feature can also be used for the upright font too:
% \begin{Verbatim}
%   \fontspec[UprightFont={* SemiBold},
%             BoldFont={* Bold}]{Baskerville}
% \end{Verbatim}
%
% \subsubsection{Small caps and slanted font shapes}
%
% For the rare situations where a font family will have slanted \emph{and}
% italic shapes, these may be specified separately using the analogous
% features \feat{SlantedFont} and \feat{BoldSlantedFont}. Without these,
% however, the \LaTeX\ font switches for slanted (\cs{textsl}, \cs{slshape})
% will default to the italic shape.
%
% Old-fashioned font families used to distribute their small caps
% glyphs in separate fonts due to the limitations on the number
% of glyphs allowed in the PostScript Type~1 format. Such fonts may be used
% by declaring the \feat{SmallCapsFont} of the family you are specifying:
% \begin{Verbatim}
%   \fontspec[
%     SmallCapsFont={Minion MM Small Caps & Oldstyle Figures}
%            ]{Minion MM Roman}
%   Roman 123 \\ \textsc{Small caps 456}
% \end{Verbatim}
% For most modern fonts that have small caps as a font feature, this level of
% control isn't generally necessary, but you may still occasionally find font
% families in which the small caps are in a separate font.
%
% All of the bold, italic, and small caps fonts can be loaded with different
% font features from the main font. See \ref{sec:bfit-feat} for details.
% When an OpenType font is selected for |SmallCapsFont|, the small caps
% font feature is \emph{not} automatically enabled. In this case, users
% should write instead
% \begin{Verbatim}
%   \fontspec[
%     SmallCapsFont={...},
%     SmallCapsFeatures={Letters=SmallCaps},
%            ]{...}
% \end{Verbatim}
%
% \subsection{Math(s) fonts}
%
% When \cmd\setmainfont, \cmd\setsansfont\ and \cmd\setmonofont\ are used in the
% preamble, they also define the fonts to be used in maths mode inside the
% \cmd\mathrm-type commands. This only occurs in the preamble because \LaTeX\
% freezes the maths fonts after this stage of the processing. The \pkg{fontspec}
% package must also be loaded after any maths font packages (\eg, \pkg{euler})
% to be successful. (Actually, it is \emph{only} \pkg{euler} that is the
% problem.\note{Speaking of \pkg{euler}, if you want to use its
% \texttt{[mathbf]} option, it won't work, and you'll need to put this after
% \pkg{fontspec} is loaded instead:
% \ttfamily\cmd\AtBeginDocument\char`\{\cmd\DeclareMathAlphabet\cmd\mathbf\char`\{U\char`\}\char`\{eur\char`\}\char`\{b\char`\}\char`\{n\char`\}})
%
% Note that you may find that loading some maths packages won't be as smooth as
% you expect since \pkg{fontspec} (and \XeTeX\ in general) breaks many of the
% assumptions of \TeX\ as to where maths characters and accents can be found.
% Contact me if you have troubles, but I can't guarantee to be able to fix any
% incompatibilities. The Lucida and Euler maths fonts should be fine; for all
% others keep an eye out for problems.
%
% \cmdbox{
%   \cmd{\setmathrm} \oarg{font features} \marg{font name} \\
%   \cmd{\setmathsf} \oarg{font features} \marg{font name} \\
%   \cmd{\setmathtt} \oarg{font features} \marg{font name} \\
%   \cmd{\setboldmathrm} \oarg{font features} \marg{font name}
% }
%
% However, the default text fonts may not necessarily be the ones you
% wish to use when typesetting maths (especially with the use of fancy
% ligatures and so on). For this reason, you may optionally use the
% commands above (in the same way as our other
% \cmd\fontspec-like commands) to explicitly state which fonts to use
% inside such commands as \cmd\mathrm. Additionally, the
% \cmd\setboldmathrm\ command allows you define the font used for
% \cmd\mathrm\ when in bold maths mode (which is activated with, among
% others, \cmd\boldmath).
%
% For example, if you were using Optima with the Euler maths font, you
% might have this in your preamble:
% \begin{Verbatim}
%   \usepackage{mathpazo}
%   \usepackage{fontspec,xunicode}
%   \setmainfont{Optima}
%   \setmathrm{Optima}
%   \setboldmathrm[BoldFont={Optima ExtraBlack}]{Optima Bold}
% \end{Verbatim}
%
%
% \subsection{Miscellaneous font selecting details}
%
% \paragraph{Spaces}
% \cmd\fontspec\ and \cmd\addfontfeatures\ ignore trailing spaces as
% if it were a `naked' control sequence; \eg, `|M. \fontspec{...} N|' and
% `|M. \fontspec{...}N|' are the same.
%
% \paragraph{Italic small caps}
% Note that this package redefines the \cs{itshape} and \cs{scshape}
% commands in order to allow them to select italic small caps in
% conjunction.
%
% \paragraph{Emphasis and nested emphasis}
% You may specify the behaviour of the \cs{emph} command by setting the
% \cs{emshape} command. \Eg, for bold emphasis:\par
% \indent|\renewcommand\emshape{\bfseries}|\par\noindent
% Nested emphasis is controlled by the \cs{eminnershape} command.
% For example, for |\emph{\emph{...}}| to produce small caps:\par
% \indent|\renewcommand\eminnershape{\scshape}|\par\noindent
%
%
%
%
%
% \section{Selecting font features}
% \label{sec:selectingfeature}
%
% The commands discussed so far such as \cmd{fontspec} each take an optional argument for
% accessing the font features of the requested font.
% Commands are provided to set default features to be applied for all fonts, and even to change the features that a font is presently loaded with.
% Different font shapes can be loaded with separate features, and different features can even be selected for different sizes that the font appears in.
% This section discusses these options.
%
% \subsection{Default settings} \label{sec:defaults}
%
% \cmdbox{\cmd\defaultfontfeatures \marg{font features}}
%
% It is desirable to define
% options that are applied to every subsequent font selection command:
% a default feature set, so to speak. This may be defined with the
% \cmd{\defaultfontfeatures} command, shown in \exref{dff}.
% New calls of \cs{defaultfontfeatures} overwrite previous ones.
%
% \begin{Xexample}{dff}{A demonstration of the \cs{defaultfontfeatures} command.}
%   \fontspec{TeX Gyre Adventor}
%   Some default text 0123456789 \\
%   \defaultfontfeatures{
%      Numbers=OldStyle, Color=888888
%   }
%   \fontspec{TeX Gyre Adventor}
%   Now grey, with old-style figures:
%   0123456789
% \end{Xexample}
%
% \subsection{Changing the currently selected features}
% \label{sec:addfontfeatures}
%
% \cmdbox{\cmd\addfontfeatures \marg{font features}}
%
% This command allows font features to
% be changed without knowing what features are currently selected or even what
% font is being used. A good example of this could be to add a hook to all
% tabular material to use monospaced numbers, as shown in \exref{aff}.
%
% \begin{Lexample}{aff}{A demonstration of the \cs{addfontfeatures} command.}
%   \fontspec[Numbers={Proportional,OldStyle}]
%            {TeX Gyre Adventor}
%   `In 1842, 999 people sailed 97 miles in
%    13 boats. In 1923, 111 people sailed 54
%    miles in 56 boats.'            \bigskip
%
%   {\addfontfeatures{Numbers={Monospaced,Lining}}
%   \begin{tabular}{@{} cccc @{}}
%             Year & People & Miles & Boats \\
%     \hline  1842 &  999   &  75   &  13   \\
%             1923 &  111   &  54   &  56
%   \end{tabular}}
% \end{Lexample}
%
% \DescribeMacro{\addfontfeature}
% This command may also be executed under the alias \cmd{\addfontfeature}.
%
% \subsection{Priority of feature selection}
% Features defined with \cs{addfontfeatures} override features
% specified by \cs{fontspec}, which in turn override features
% specified by \cs{defaultfontfeatures}.  If in doubt, whenever a
% new font is chosen for the first time, an entry is made in the
% transcript (\texttt{.log}) file displaying the font name and the
% features requested.
%
% \subsection{Different features for different font shapes}
% \label{sec:bfit-feat}
%
% \cmdbox{
%  \feat{BoldFeatures}\marg{features} \\
%  \feat{ItalicFeatures}\marg{features} \\
%  \feat{BoldItalicFeatures}\marg{features} \\
%  \feat{SlantedFeatures}\marg{features} \\
%  \feat{BoldSlantedFeatures}\marg{features} \\
%  \feat{SmallCapsFeatures}\marg{features}
% }
%
% It is entirely possible that separate fonts in a family will require
% separate options; \eg, Hoefler Text Italic contains various swash
% feature options that are completely unavailable in the upright shapes.
%
% The font features defined at the top level of the optional \cmd\fontspec\
% argument are applied to \emph{all} shapes of the family.
% Using \feat{Upright-}, \feat{SmallCaps-}, \feat{Bold-},
% \feat{Italic-}, and \feat{BoldItalicFeatures},
% separate font features may be defined to their respective shapes
% \emph{in addition} to, and with precedence over, the `global' font features.
% See \exref{itfeat}.
%
% \begin{Xexample}{itfeat}{Features for, say, just italics.}
%   \fontspec{Hoefler Text} \itshape \scshape
%   Attention All Martini Drinkers \\
%   \addfontfeature{ItalicFeatures={Alternate = 1}}
%   Attention All Martini Drinkers \\
% \end{Xexample}
%
% Combined with the options for selecting arbitrary \emph{fonts} for
% the different shapes, these separate feature options allow the
% selection of arbitrary weights in the Skia typeface, as shown in \exref{bffeat}.
%
% \begin{Xexample}{bffeat}{Multiple Master--like features in AAT fonts.}
%   \fontspec[BoldFont={Skia},
%    BoldFeatures={Weight=2}]{Skia}
%   Skia \\ \bfseries Skia `Bold'
% \end{Xexample}
%
% Note that because most fonts include their small caps glyphs
% within the main font, features specified with \feat{SmallCapsFeatures} are applied \emph{in addition} to
% any other shape-specific features as defined above, and hence \feat{SmallCapsFeatures}
% can be nested within \feat{ItalicFeatures} and friends. Every combination
% of upright, italic, bold and small caps can thus be assigned individual
% features, as shown in the somewhat ludicrous \exref{scfeat}.
%
% \begin{Xexample}{scfeat}{An example of setting the \feat{SmallCapsFeatures}
% separately for each font shape.}
%   \fontspec[
%       UprightFeatures={Color = 220022,
%            SmallCapsFeatures = {Color=115511}},
%        ItalicFeatures={Color = 2244FF,
%            SmallCapsFeatures = {Color=112299}},
%          BoldFeatures={Color = FF4422,
%            SmallCapsFeatures = {Color=992211}},
%    BoldItalicFeatures={Color = 888844,
%            SmallCapsFeatures = {Color=444422}},
%            ]{TeX Gyre Termes}
%   Upright {\scshape Small Caps}\\
%   \itshape Italic {\scshape Italic Small Caps}\\
%   \upshape\bfseries Bold {\scshape Bold Small Caps}\\
%   \itshape Bold Italic {\scshape Bold Italic Small Caps}
% \end{Xexample}
%
% \subsection{Different features for different font sizes}
% \label{sec:sizefeature}
%
% \cmdbox{
% \ttfamily SizeFeatures = \char`\{\\
% \null\quad...\\
% \null\quad\char`\{~Size =
% \rmfamily\meta{size range}\ttfamily
% ,
% \rmfamily \meta{font features}\ttfamily
% ~\char`\} , \\
% \null\quad\char`\{~Size =
% \rmfamily\meta{size range}\ttfamily
% , Font =
% \rmfamily\meta{font name}\texttt, \meta{font features}\ttfamily
% ~\char`\} , \\
% \null\quad... \\
% \char`\}}
%
% The \feat{SizeFeature} feature is a little more complicated
% than the previous features discussed. It allows different fonts
% and different font features to be selected for a given font
% family as the point size varies.
%
% It takes a comma separated list of braced, comma separated lists of features for each size range.
% Each sub-list must contain the \opt{Size} option
% to declare the size range, and optionally \opt{Font} to change the
% font based on size. Other (regular) fontspec features that are added
% are used on top of the font features that would be used anyway.
% A demonstration to hopefully clarify these details is shown in \exref{sizefeat}.
% A less trivial example is shown in the context of optical font sizes
% in \vref{sec:opticalsize}.
%
% \begin{Xexample}{sizefeat}{An example of specifying different font features for different sizes of font with \feat{SizeFeatures}.}
%   \fontspec[ SizeFeatures={
%       {Size={-8}, Font=TeX Gyre Bonum Italic, Color=AA0000},
%       {Size={8-14}, Color=00AA00},
%       {Size={14-}, Color=0000AA}} ]{TeX Gyre Chorus}
%
%   {\scriptsize Small\par} Normal size\par {\Large Large\par}
% \end{Xexample}
%
% To be precise, the \opt{Size} sub-feature accepts arguments in the form shown in \vref{tab:sizing}.
% Braces around the size range are optional. For an exact font size (|Size=X|)
% font sizes chosen near that size will `snap'. For example, for size definitions
% at exactly 11pt and 14pt, if a 12pt font is requested \emph{actually} the
% 11pt font will be selected. This is a remnant of the past when fonts were designed
% in metal (at obviously rigid sizes) and later when bitmap fonts were similarly
% designed for fixed sizes.
%
% If additional features are only required for a single size, the other sizes
% must still be specified.  As in:
% \begin{verbatim}
%   SizeFeatures={
%      {Size=-10,Numbers=Uppercase},
%      {Size=10-}}
% \end{verbatim}
% Otherwise, the font sizes greater than 10 won't be defined!
%
% \begin{table}
% \caption{Syntax for specifying the size to apply custom font features.}\label{tab:sizing}
% \centering
% \begin{tabular}{@{}ll@{}}
% \toprule
% Input & Font size, $s$ \\
% \midrule
%  |Size = X-| & $s \geq \texttt{X}$ \\
%  |Size = -Y| & $s < \texttt{Y}$ \\
%  |Size = X-Y| & $\texttt{X} \leq s < \texttt{Y}$ \\
%  |Size = X| & $s = \texttt{X}$ \\
% \bottomrule
% \end{tabular}
% \end{table}
%
%
% \section{Font independent options} \label{sec:font-ind-features}
%
% Features introduced in this section may be used with any font.
%
% \subsection{Colour}
%
% \feat{Color} (or \feat{Colour}), also shown in \vref{sec:defaults}
% and elsewhere, uses font specifications to set the colour of
% the text. The colour is defined as a triplet of two-digit Hex RGB
% values, with optionally another value for the transparency (where
% |00| is completely transparent and |FF| is opaque.)
% \begin{Xexample}{color}{Selecting colour with transparency.}
%   \fontsize{48}{48}
%   \fontspec{TeX Gyre Bonum Bold}
%   {\addfontfeature{Color=FF000099}W}\kern-1ex
%   {\addfontfeature{Color=0000FF99}S}\kern-0.8ex
%   {\addfontfeature{Color=DDBB2299}P}\kern-0.8ex
%   {\addfontfeature{Color=00BB3399}R}
% \end{Xexample}
% Transparency is supported by \LuaLaTeX and by \XeLaTeX\ with the \texttt{xdv2pdf}
% driver (\MacOSX\ only); \XeLaTeX\ with the \texttt{xdvipdfmx} driver
% does not support this feature.
%
% If you load the \pkg{xcolor} package, you may use any named colour instead
% of writing the colours in hexadecimal.
% \begin{Verbatim}
%  \usepackage{xcolor}
%  ...
%  \fontspec[Color=red]{Verdana} ...
%  \definecolor{Foo}{rgb}{0.3,0.4,0.5}
%  \fontspec[Color=Foo]{Verdana} ...
% \end{Verbatim}
% The \pkg{color} package is \emph{not} supported; use \pkg{xcolor} instead.
%
% You may specify the transparency with a named colour using the \feat{Opacity}
% feature:
% \begin{Verbatim}
%  \fontspec[Color=red,Opacity=0.7]{Verdana} ...
% \end{Verbatim}
%
% \subsection{Scale}
%
% \cmdbox{
%  \feat{Scale} = \meta{number} \\
%  \feat{Scale} = \opt{MatchLowercase} \\
%  \feat{Scale} = \opt{MatchUppercase}
% }
%
% In its explicit form, \feat{Scale} takes a single
% numeric argument for linearly scaling the font, as demonstrated
% in \vref{sec:setxxfont}.
% It is now possible to
% measure the correct dimensions of the fonts loaded and
% calculate values to scale them automatically.
%
% As well as a numerical argument, \feat{Scale} feature
% also accepts options \opt{MatchLowercase}
% and \opt{MatchUppercase}, which will scale the font being selected to match
% the current default roman font to either the height of the lowercase or
% uppercase letters, respectively; these features are shown in \exref{scale}.
%
% \begin{Xexample}{scale}{Automatically calculated scale values.}
%   \setmainfont{Georgia}
%   \newfontfamily\lc[Scale=MatchLowercase]{Verdana}
%    The perfect match {\lc is hard to find.}\\
%   \newfontfamily\uc[Scale=MatchUppercase]{Arial}
%    L O G O \uc F O N T
% \end{Xexample}
%
% The amount of scaling used in each instance is reported in the \texttt{.log} file.
% Since there is some subjectivity about the exact scaling to be used, these values
% should be used to fine-tune the results.
%
%
%
%
% \subsection{Interword space}
%
% While the space between words can be varied on an individual
% basis with the \TeX\ primitive \cmd\spaceskip\ command, it is
% more convenient to specify this information when the font is
% first defined.
%
% The space in between words in a paragraph will be chosen automatically,
% and generally will not need to be adjusted. For those
% times when the precise details are important, the \feat{WordSpace}
% feature is
% provided, which takes either a single scaling factor to scale the
% default value, or a triplet of comma-separated
% values to scale the nominal value, the stretch, and the shrink of the
% interword space by, respectively. (|WordSpace={|$x$|}| is the same as
% |WordSpace={|$x$|,|$x$|,|$x$|}|.)
%
% \begingroup
% \let\centering\relax
% \begin{Xexample}{wordspace}{Scaling the default interword space. An exaggerated value has been chosen to emphasise the effects here.}
%   \fontspec{TeX Gyre Termes}
%   Some text for our example to take
%   up some space, and to demonstrate
%   the default interword space.
%   \bigskip
%
%   \addfontfeature{ WordSpace = 0.3 }
%   Some text for our example to take
%   up some space, and to demonstrate
%   the default interword space.
% \end{Xexample}
% \endgroup
%
% \subsection{Post-punctuation space}
%
% If \cmd\frenchspacing\ is \emph{not} in effect, \TeX\ will allow extra
% space after some punctuation in its goal of justifying the lines of text.
% Generally, this is considered old-fashioned, but occasionally in small amounts the
% effect can be justified, pardon the pun.
%
% The \feat{PunctuationSpace} feature takes a scaling factor by which to
% adjust the nominal value chosen for the font; this is demonstrated in
% \exref{punctspace}.
% Note that |PunctuationSpace=0|
% is \emph{not} equivalent to \cmd\frenchspacing, although the difference
% will only be apparent when a line of text is under-full.
%
% \begin{Lexample}{punctspace}{Scaling the default post-punctuation space.}
%   \nonfrenchspacing
%   \fontspec{TeX Gyre Schola}
%    Letters, Words. Sentences.          \par
%   \fontspec[PunctuationSpace=2]{TeX Gyre Schola}
%    Letters, Words. Sentences.          \par
%   \fontspec[PunctuationSpace=0]{TeX Gyre Schola}
%    Letters, Words. Sentences.
% \end{Lexample}
%
%
%
%
% \subsection{The hyphenation character}
%
% The letter used for hyphenation may be chosen with the \feat{HyphenChar}
% feature. It takes three types of input, which are chosen according to some
% simple rules. If the input is the string \opt{None}, then hyphenation is
% suppressed for this font.
% If the input is a single character, then this
% character is used. Finally, if the input is longer than a single character
% it must be the UTF-8 slot number of the hyphen character you desire.
%
% This package
% redefines \LaTeX's \cmd\-\ macro
% such that it adjusts along with the above changes.
%
% \begin{Xexample}{hyphchar}{Explicitly choosing the hyphenation character.}
%  \def\text{\fbox{\parbox{1.55cm}{%
%    EXAMPLE HYPHENATION%
%  }}\qquad\qquad\null\par\bigskip}
%
%  \fontspec{Linux Libertine}
%  \addfontfeature{HyphenChar=None}
%  \text
%  \addfontfeature{HyphenChar={+}}
%  \text
% \end{Xexample}
%
% \subsection{Optical font sizes} \label{sec:opticalsize}
%
% Optically scaled fonts thicken out as the font size decreases
% in order to make the glyph shapes more robust (less prone to losing
% detail), which improves legibility. Conversely, at large optical
% sizes the serifs and other small details may be more delicately
% rendered.
%
% OpenType fonts with optical scaling will exist in
% several discrete sizes, and these will be selected by \XeTeX\
% \emph{automatically} determined by the current font size as in
% \exref{optsize}, in which we've scaled down some large text in order to be
% able to compare the difference for equivalent font sizes.
%
% The
% \opt{OpticalSize} option may be used to specify a different optical
% size.
% With \opt{OpticalSize} set
% to zero, no optical size font substitution is performed, as shown in
% \exref{optsize0}.
%
% \begin{Xexample}{optsize}{A demonstration of automatic optical size selection.}
%   \fontspec{Latin Modern Roman}
%    Automatic optical size                  \\
%   \scalebox{0.4}{\Huge
%    Automatic optical size}
% \end{Xexample}
%
% \begin{Xexample}{optsize0}{Optical size substitution is suppressed when set to zero.}
%   \fontspec[OpticalSize=0]{Latin Modern Roman 5 Regular}
%    Latin Modern optical sizes                \\
%   \fontspec[OpticalSize=0]{Latin Modern Roman 8 Regular}
%    Latin Modern optical sizes                \\
%   \fontspec[OpticalSize=0]{Latin Modern Roman 12 Regular}
%    Latin Modern optical sizes                \\
%   \fontspec[OpticalSize=0]{Latin Modern Roman 17 Regular}
%    Latin Modern optical sizes
% \end{Xexample}
%
% The \feat{SizeFeatures} feature (\vref*{sec:sizefeature}) can be
% used to specify exactly which optical sizes will be used for ranges
% of font size. For example, something like:
% \begin{verbatim}
%   \fontspec[
%     SizeFeatures={
%       {Size=-10,     OpticalSize=8 },
%       {Size= 10-14,  OpticalSize=10},
%       {Size= 14-18,  OpticalSize=14},
%       {Size=    18-, OpticalSize=18}}
%            ]{Latin Modern Roman}
% \end{verbatim}
%
% \part{OpenType}
% \label{sec:opentype-features}
%
% \section{Introduction}
% \label{sec:opentype-features-intro}
%
% OpenType fonts (and other `smart' font technologies such as AAT and Graphite) can change the appearance of text in many different ways.
% These changes are referred to as features.
% When the user applies a feature~--- for example, small capitals~--- to a run of text, the code inside the font makes appropriate adjustments and small capitals appear in place of lowercase letters.
% However, the use of such features does not affect the underlying text.
% In our small caps example, the lowercase letters are still stored in the document; only the appearance has been changed by the OpenType feature.
% This makes it possible to search and copy text without difficulty.
% If the user selected a different font that does not support small caps, the `plain' lowercase letters would appear instead.
%
% Some OpenType features are required to support particular scripts, and these features are often applied automatically.
% The scripts used in India, for example, often require that characters be reshaped and reordered after they are typed by the user, in order to display them in the traditional ways that readers expect.
% Other features can be applied to support a particular language.
% The Junicode font for medievalists uses by default the Old English shape of the letter thorn, while in modern Icelandic thorn has a more rounded shape.
% If a user tags some text as being in Icelandic, Junicode will automatically change to the Icelandic shape through an OpenType feature that localizes the shapes of letters.
%
% A very large group of OpenType features is designed to support high quality typography in Latin, Greek, Cyrillic and other standard scripts.
% Examples of some font features have already been shown in previous sections; the complete set of OpenType font features supported by \pkg{fontspec} is described below in \ref{sec:ot-feat}.
%
% The OpenType specification provides four-letter codes (e.g., \texttt{smcp} for small capitals) for each feature.  The four-letter codes are given below along with the \pkg{fontspec} names for various features, for the benefit of people who are already familiar with OpenType.  You can ignore the codes if they don't mean anything to you.
%
%
% \subsection{How to select font features}
%
% Font features are selected by a series of \meta{feature}=\meta{option}
% selections. Features are (usually) grouped logically; for example, all
% font features relating to ligatures are accessed by writing \verb|Ligatures={...}| with the appropriate argument(s), which could be \texttt{TeX}, \texttt{Rare}, etc., as shown below in \ref{sec:ot-feat-liga}.
%
% Multiple options may be given to
% any feature that accepts non-numerical input, although doing so will
% not always work. Some options will override others in generally
% obvious ways; \Verb|Numbers={OldStyle,Lining}| doesn't make much
% sense because the two options are mutually exclusive, and \XeTeX\
% will simply use the last option that is specified (in this case
% using \opt{Lining} over \opt{OldStyle}).
%
% If a feature or an option is requested that the font does not have,
% a warning is given in the console output. As mentioned in \vref{sec:quiet-warnings}
% these warnings can be suppressed by selecting the \texttt{[quiet]} package option.
%
% \section{Complete listing of OpenType font features}
% \label{sec:ot-feat}
%
% \subsection{Ligatures}
% \label{sec:ot-feat-liga}
%
% \feat{Ligatures} refer to the replacement of two separate characters
% with a specially drawn glyph for functional or \ae sthetic reasons.
% The list of options, of which multiple may be selected at one time,
% is shown in \ref{feat:Ligatures}.
% A demonstration with the Linux Libertine fonts\note{\url{http://www.linuxlibertine.org/}} is shown in \exref{lig}.
%
% Note the additional features accessed with \verb|Ligatures=TeX|. These are
% not actually real OpenType features, but additions provided by \pkg{luaotfload} (i.e., \LuaTeX\ only) to emulate \TeX's behaviour for \textsc{ascii} input of curly quotes and punctuation. In \XeTeX\ this is achieved with the \feat{Mapping} feature (see \vref{sec:mapping}) but for consistency \verb|Ligatures=TeX| will perform the same function as \verb|Mapping=tex-text|.
%
% \begin{features}{Ligatures}
% \otf*{Required}{rlig}
% \otf*{Common}{liga}
% \otf*{Contextual}{clig}
% \otf{Rare/Discretionary}{dlig}
% \otf{Historic}{hlig}
% \otf{TeX}{tlig/trep}
% \end{features}
%
% \begin{Lexample}[firstline=2]{lig}{An example of the \feat{Ligatures} feature.}
%    \Huge\centering
%    \def\test#1#2{%
%      #2 $\to$ {\addfontfeature{#1} #2}\\}
%    \fontspec{Linux Libertine}
%    \test{Ligatures=Historic}{strict}
%    \test{Ligatures=Rare}{wurtzite}
%    \test{Ligatures=NoCommon}{firefly}
% \end{Lexample}
%
% \subsection{Letters} \label{sec:letters}
% The \opt{Letters} feature specifies how the letters in the current font
% will look. OpenType fonts may contain the following options:
% \opt{Uppercase}, \opt{SmallCaps}, \opt{PetiteCaps},
% \opt{UppercaseSmallCaps}, \opt{UppercasePetiteCaps}, and
% \opt{Unicase}.
%
% \begin{features}{Letters}
% \otf{Uppercase}{case}
% \otf{SmallCaps}{smcp}
% \otf{PetiteCaps}{pcap}
% \otf{UppercaseSmallCaps}{c2sc}
% \otf{UppercasePetiteCaps}{c2pc}
% \otf{Unicase}{unic}
% \end{features}
%
% Petite caps are smaller than small caps.
% \opt{SmallCaps} and \opt{PetiteCaps}
% turn lowercase letters into the smaller caps letters,
% whereas the \opt{Uppercase...} options turn the \emph{capital} letters into
% the smaller
% caps (good, \eg, for applying to already uppercase acronyms like
% `NASA').
% This difference is shown in \exref{caps}.
% `Unicase' is a weird hybrid of upper and lower case letters.
%
% \begin{Lexample}{caps}{Small caps from lowercase or uppercase letters.}
%   \fontspec[Letters=SmallCaps]{TeX Gyre Adventor}
%    THIS SENTENCE no verb                \\
%   \fontspec[Letters=UppercaseSmallCaps]{TeX Gyre Adventor}
%    THIS SENTENCE no verb
% \end{Lexample}
%
% Note that the \opt{Uppercase} option will (probably)
% not actually map letters to uppercase.
%  \note{If you want automatic uppercase letters, look to \LaTeX's
%       \cmd\MakeUppercase\ command.}
% It is designed select various
% uppercase forms for glyphs such as accents and dashes, such as shown
% in \exref{letters-uppercase}; note the raised position of the hyphen
% to better match the surrounding letters.
%
% \begin{Lexample}{letters-uppercase}{An example of the \opt{Uppercase} option of the \feat{Letters} feature.}
%   \fontspec{Linux Libertine}
%    UPPER-CASE example \\
%   \addfontfeature{Letters=Uppercase}
%    UPPER-CASE example
% \end{Lexample}
%
% The \feat{Kerning} feature also contains an \opt{Uppercase} option,
% which adds a small amount of spacing in between letters (see \vref{sec:kerning}).
%
% \subsection{Numbers}
%
% The \feat{Numbers} feature defines how numbers will look in the
% selected font, accepting options shown in \ref{feat:Numbers}.
%
% \begin{features}{Numbers}
% \otf{Uppercase/Lining}{lnum}
% \otf{Lowercase/OldStyle}{onum}
% \otf{Proportional}{pnum}
% \otf{Monospaced}{tnum}
% \otf{SlashedZero}{zero}
% \otf{Arabic}{anum}
% \end{features}
%
% The synonyms
% \opt{Uppercase} and \opt{Lowercase} are equivalent to \opt{Lining} and
% \opt{OldStyle}, respectively.
% The differences have been shown previously
% in \vref{sec:addfontfeatures}.
% The \opt{Monospaced} option is useful for tabular material when digits need
% to be vertically aligned.
%
% The \opt{SlashedZero} option
% replaces the default zero with a slashed version to prevent
% confusion with an uppercase `O', shown in \exref{slashzero}.
%
% \begin{Lexample}{slashzero}{The effect of the \opt{SlashedZero} option.}
%   \fontspec[Numbers=Lining]{TeX Gyre Bonum}
%    0123456789
%   \fontspec[Numbers=SlashedZero]{TeX Gyre Bonum}
%    0123456789
% \end{Lexample}
%
% The \opt{Arabic} option (with tag \verb|anum|) maps regular numerals to their Arabic script or Persian equivalents
% based on the current \opt{Language} setting (see \vref{sec:ot}), shown in
% \exref{num-arab} using the Zar fonts\note{\url{http://wiki.irmug.org/index.php/X_Series_2}}.
% This option is based on a \LuaTeX\ feature of the \pkg{luaotfload} package,
% not an OpenType feature. (Thus, this feature is unavailable in \XeTeX.)
%
% \begin{Lexample}[firstline=2]{num-arab}{An example of number remapping to Arabic or Persian. (\LuaTeX\ only.)}
%   \huge
%   \fontspec[Script=Arabic,Numbers=Arabic]{XB Zar}
%   {\addfontfeature{Language=Arabic}
%    0123456789} \\
%   {\addfontfeature{Language=Parsi}
%    0123456789}
% \end{Lexample}
%
% \subsection{Contextuals}
% This feature refers to substitutions of glyphs that vary `contextually' by their relative position in a word or string of characters;
% features such as contextual swashes are accessed here.
%
% \begin{features}{Contextuals}
% \otf{Swash}{cswh}
% \otf{Alternate}{calt}
% \otf{WordInitial}{init}
% \otf{WordFinal}{fina}
% \otf{LineFinal}{falt}
% \otf{Inner}{medi}
% \end{features}
%
% \begin{Lexample}{swash}{An example of the \opt{Swashes} option of the \opt{Contextuals} feature.}
%   \fontspec{Warnock Pro} \itshape
%    Without Contextual Swashes             \\
%   \fontspec[Contextuals=Swash]{Warnock Pro}
%    With Contextual Swashes; cf. W C S
% \end{Lexample}
%
% Historic forms are accessed in OpenType
% fonts via the feature \feat{Style=Historic}; this is generally \emph{not}
% contextual in OpenType, which is why it is not included here.
%
% \subsection{Vertical Position}
%
% \begin{features}{VerticalPosition}
% \otf{Superior}{sups}
% \otf{Inferior}{subs}
% \otf{Numerator}{numr}
% \otf{Denominator}{dnom}
% \otf{ScientificInferior}{sinf}
% \otf{Ordinal}{ordn}
% \end{features}
%
% The \feat{VerticalPosition} feature is used to access things like
% subscript (\opt{Inferior}) and superscript (\opt{Superior}) numbers and
% letters (and a small amount of punctuation, sometimes).
% The \opt{Ordinal} option will only raise characters that are used
% in some languages directly after a number.
% The \opt{ScientificInferior} feature will move glyphs
% further below the baseline than the \opt{Inferior} feature.
% These are shown in \exref{vertpos}
%
% \opt{Numerator} and \opt{Denominator} should only be used for creating
% arbitrary fractions (see next section).
%
% \begin{Lexample}{vertpos}{The \feat{VerticalPosition} feature. Note that the \opt{Ordinal} option can be quite unreliable, as the results here demonstrate.}
%   \fontspec[VerticalPosition=Superior]{Warnock Pro}
%    Sup: abdehilmnorst (-\$12,345.67)                      \\
%   \fontspec[VerticalPosition=Numerator]{Warnock Pro}
%    Numerator: 12345                                       \\
%   \fontspec[VerticalPosition=Denominator]{Warnock Pro}
%    Denominator: 12345                                     \\
%   \fontspec[VerticalPosition=ScientificInferior]{Warnock Pro}
%    Scientific Inferior: 12345                             \\
%   \fontspec[VerticalPosition=Ordinal]{Warnock Pro}
%   `Ordinals': 1st 2nd 3rd 4th 0th
% \end{Lexample}
%
% The \pkg{realscripts} package
% (which is also loaded \pkg{xltxtra} for \XeTeX)
% redefines the \cmd\textsubscript\ and
% \cmd\textsuperscript\ commands to use the above font features automatically,
% including for use in footnote labels.
%
%
% \subsection{Fractions}
%
% \begin{features}{Fractions}
% \otf{On}{frac}
% \otf{Alternate}{afrc}
% \end{features}
%
% For OpenType fonts use a regular text slash to create fractions, but
% the \feat{Fraction} feature must be explicitly activated.
% Some (Asian fonts predominantly) also provide for the
% \opt{Alternate} feature. These are both shown in \exref{ot-frac}.
%
% \begin{Xexample}{ot-frac}{The \feat{Fractions} feature.}
%   \fontspec{Hiragino Maru Gothic Pro W4}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680 \\
%   \addfontfeature{Fractions=On}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680 \\
%   \addfontfeature{Fractions=Alternate}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680 \\
% \end{Xexample}
%
%
% \subsection{Stylistic Set variations}
%
% This feature selects a `Stylistic Set' variation,
% which usually corresponds to an alternate glyph style for a range of
% characters (usually an alphabet or subset thereof).
% This feature is specified numerically. These correspond to OpenType
% features |ss01|, |ss02|, etc.
%
% Two demonstrations from the Junicode
% font\note{\url{http://junicode.sf.net}}
% are shown in \exref{ss} and \exref{ss2}; thanks to Adam
% Buchbinder for the suggestion.
%
% \begin{Lexample}{ss}{Insular letterforms, as used in medieval Northern Europe, for the Junicode font accessed with the \feat{StylisticSet} feature.}
%   \fontspec{Junicode}
%    Insular forms. \\
%   \addfontfeature{StylisticSet=2}
%    Insular forms. \\
% \end{Lexample}
%
% \begin{Lexample}{ss2}{Enlarged minuscules (capital letters remain unchanged) for the Junicode font, accessed with the \feat{StylisticSet} feature.}
%   \fontspec{Junicode}
%    ENLARGED Minuscules. \\
%   \addfontfeature{StylisticSet=6}
%    ENLARGED Minuscules. \\
% \end{Lexample}
%
% (This is a synonym of the \feat{Variant} feature for \AAT\ fonts.)
% See \vref{sec:newfeatures} for a way to assign names to stylistic sets,
% which should be done on a per-font basis.
%
% \subsection{Character Variants}
%
% Similar to the `Stylistic Sets' above, `Character Variations' are selected
% numerically to adjust the output of (usually) a single character for the
% particular font. These correspond to the OpenType features |cv01| to |cv99|.
%
% I don't have a font to demonstrate this with (please suggest one if you
% know of a free font with this feature!), but the syntax is similar to that
% above:
% \begin{verbatim}
%   \fontspec[CharacterVariant={1,3,5}]{...}
% \end{verbatim}
%
% \subsection{Alternates}
%
% The \feat{Alternate} feature (for the raw OpenType feature |salt|) is used to access alternate font glyphs when variations exist in the font, such as in \exref{salt}.
% It uses a numerical selection, starting from zero, that will be different for each font.
% Note that the \texttt{Style=Alternate} option is equivalent
% to \texttt{Alternate=0} to access the default case.
%
% \begin{Xexample}[firstline=2]{salt}{The \feat{Alternate} feature.}
%   \huge
%   \fontspec{Linux Libertine}
%   \textsc{a} \& h \\
%   \addfontfeature{Alternate=0}
%   \textsc{a} \& h
% \end{Xexample}
%
% See \vref{sec:newfeatures} for a way to assign names to alternates,
% which must be done on a per-font basis.
%
% \subsection{Style}
% \label{sec:ot-feat-style}
%
% \begin{features}{Style}
% \otf{Alternate}{salt}
% \otf{Italic}{ital}
% \otf{Ruby}{ruby}
% \otf{Swash}{swsh}
% \otf{Historic}{hist}
% \otf{TitlingCaps}{titl}
% \otf{HorizontalKana}{hkna}
% \otf{VerticalKana}{vkna}
% \end{features}
%
% `Ruby' refers to a small optical size, used in
% Japanese typography for annotations.
% For fonts with multiple |salt| OpenType features,
% use the fontspec \feat{Alternate} feature instead.
%
% \Exref{style-alt} and \exref{style-hist} both contain glyph
% substitutions with similar characteristics.
% Note the occasional inconsistency with which font features are labelled; a long-tailed `Q' could turn up anywhere!
%
%  \begin{Xexample}[firstline=2]{style-alt}{Example of the \opt{Alternate} option of the \feat{Style} feature.}
%   \Large
%   \fontspec{Warnock Pro}
%    K Q R k v w y                      \\
%   \addfontfeature{Style=Alternate}
%    K Q R k v w y
% \end{Xexample}
%
% \begin{Xexample}[firstline=2]{style-hist}{Example of the \opt{Historic} option of the \feat{Style} feature.}
%   \Large
%   \fontspec{Adobe Jenson Pro}
%    M Q Z                      \\
%   \addfontfeature{Style=Historic}
%    M Q Z
% \end{Xexample}
%
% In other features, larger breadths of changes can be seen, covering
% the style of an entire alphabet. See \exref{style-titl} and \exref{style-itrub}; in the latter, the \opt{Italic} option affects the Latin text and the \opt{Ruby} option the Japanese.
%
% \begin{Xexample}[firstline=2]{style-titl}{Example of the \opt{TitlingCaps} option of the \feat{Style} feature.}
%   \Large
%   \fontspec{Adobe Garamond Pro}
%    TITLING CAPS                       \\
%   \addfontfeature{Style=TitlingCaps}
%    TITLING CAPS
% \end{Xexample}
%
% \begin{Xexample}[firstline=2]{style-itrub}{Example of the \opt{Italic} and \opt{Ruby} options of the \feat{Style} feature.}
%   \Large \def\kana{ }
%   \fontspec{Hiragino Mincho Pro}
%    Latin \kana        \\
%   \addfontfeature{Style={Italic, Ruby}}
%    Latin \kana
% \end{Xexample}
%
% Note the difference here between the default and the horizontal style kana
% in \exref{style-hvkana}: the horizontal style is slightly wider.
%
% \begin{Xexample}[firstline=2]{style-hvkana}{Example of the \opt{HorizontalKana} and \opt{VerticalKana} options of the \feat{Style} feature.}
%   \Large \def\kana{ }
%    \fontspec{Hiragino Mincho Pro}
%     \kana   \\
%   {\addfontfeature{Style=HorizontalKana}
%     \kana } \\
%   {\addfontfeature{Style=VerticalKana}
%     \kana }
% \end{Xexample}
%
% \subsection{Diacritics}
% Specifies how combining diacritics should be placed.
% These will usually be controlled automatically
% according to the Script setting.
%
% \begin{features}{Diacritics}
% \otf*{MarkToBase}{mark}
% \otf*{MarkToMark}{mkmk}
% \otf*{AboveBase}{abvm}
% \otf*{BelowBase}{blwm}
% \end{features}
%
% \subsection{Kerning}\label{sec:kerning}
% Specifies how inter-glyph spacing should behave.
%
% \begin{features}{Kerning}
% \otf{Uppercase}{cpsp}
% \otf*[Off]{On}{kern}
% \end{features}
%
% As briefly mentioned previously at the end of \vref{sec:letters},
% the \opt{Uppercase} option will add a small amount of tracking between uppercase letters, seen in \exref{kernup}, which uses the Romande fonts\note{\url{http://arkandis.tuxfamily.org/adffonts.html}} (thanks to Clea F. Rees for the suggestion).
%
% \begin{Xexample}[firstline=2]{kernup}{Adding extra kerning for uppercase letters. (The difference is usually very small.)}
%   \large
%   \fontspec{Romande ADF Std Bold}
%    UPPERCASE EXAMPLE \\
%   \addfontfeature{Kerning=Uppercase}
%    UPPERCASE EXAMPLE
% \end{Xexample}
%
%
% \subsection{Font transformations}
%
% In rare situations users may want to mechanically distort the shapes of the glyphs in the current font such as shown in \exref{fake}. Please don't overuse these features; they are \emph{not} a good alternative to having the real shapes.
%
% \begin{Xexample}{fake}{Articifial font transformations.}
%   \fontspec{Charis SIL} \emph{ABCxyz} \quad
%   \fontspec[FakeSlant=0.2]{Charis SIL} ABCxyz
%
%   \fontspec{Charis SIL}  ABCxyz \quad
%   \fontspec[FakeStretch=1.2]{Charis SIL} ABCxyz
%
%   \fontspec{Charis SIL} \textbf{ABCxyz} \quad
%   \fontspec[FakeBold=1.5]{Charis SIL} ABCxyz
% \end{Xexample}
%
% If values are omitted, their defaults are as shown above.
%
% If you want the bold shape to be faked automatically, or the italic shape
% to be slanted automatically, use the \feat{AutoFakeBold} and
% \feat{AutoFakeSlant} features. For example, the following two invocations
% are equivalent:
% \begin{verbatim}
%   \fontspec[AutoFakeBold=1.5]{Charis SIL}
%   \fontspec[BoldFeatures={FakeBold=1.5}]{Charis SIL}
% \end{verbatim}
%
% If both of the \feat{AutoFake...} features are used, then the bold italic
% font will also be faked.
%
% Currently, \feat{FakeStretch} doesn't work in \LuaTeX\ and will be ignored
% silently.
%
% \subsection{Annotation}
% Some fonts are equipped with an extensive range of
% numbers and numerals in different forms. These are accessed with the
% \feat{Annotation} feature (OpenType feature |nalt|), selected numerically as shown in
% \exref{ot-annot}.
%
% \begin{Xexample}{ot-annot}{Annotation forms for OpenType fonts.}
%   \fontspec{Hiragino Maru Gothic Pro}
%    1 2 3 4 5 6 7 8 9
%   \def\x#1{\\{\addfontfeature{Annotation=#1}
%             1 2 3 4 5 6 7 8 9 }}
%   \x0\x1\x2\x3\x4\x5\x6\x7\x7\x8\x9
% \end{Xexample}
%
% \subsection{CJK shape}
%
% \begin{features}{CJKShape}
% \otf{Traditional}{trad}
% \otf{Simplified} {smpl}
% \otf{JIS1978}    {jp78}
% \otf{JIS1983}    {jp83}
% \otf{JIS1990}    {jp90}
% \otf{Expert}     {expt}
% \otf{NLC}        {nlck}
% \end{features}
%
% There have been many standards for how CJK ideographic
% glyphs are `supposed' to look. Some fonts will contain many alternate
% glyphs available in order to be able to display these gylphs
% correctly in whichever form is appropriate. Both \AAT\ and OpenType
% fonts support the following \feat{CJKShape} options:
% \opt{Traditional}, \opt{Simplified}, \opt{JIS1978}, \opt{JIS1983},
% \opt{JIS1990}, and \opt{Expert}. OpenType also supports the \opt{NLC} option.

% \begin{Xexample}[firstline=2]{ot-cjk-shape}{Different standards for CJK ideograph presentation.}
%   \LARGE\def\text{  }
%   \fontspec{Hiragino Mincho Pro}
%   {\addfontfeature{CJKShape=Traditional}
%   \text }                          \\
%   {\addfontfeature{CJKShape=NLC}
%   \text }                          \\
%   {\addfontfeature{CJKShape=Expert}
%   \text }
% \end{Xexample}
%
% \subsection{Character width}\label{sec:CharacterWidth}
% Many Asian fonts are equipped with variously spaced characters for
% shoe-horning into their generally monospaced text.
% These are
% accessed through the \feat{CharacterWidth} feature.
%
% \begin{features}{CharacterWidth}
% \otf{Proportional}{pwid}
% \otf{Full}        {fwid}
% \otf{Half}        {hwid}
% \otf{Third}       {twid}
% \otf{Quarter}     {qwid}
% \otf{AlternateProportional}{palt}
% \otf{AlternateHalf}{halt}
% \end{features}
%
% Japanese alphabetic glyphs (in Hiragana or Katakana) may be typeset
% proportionally, to better fit horizontal measures, or monospaced, to
% fit into the rigid grid imposed by ideographic typesetting. In this
% latter case, there are also half-width forms for squeezing more kana
% glyphs (which are less complex than the kanji they are amongst) into
% a given block of space. The same features are given to roman letters
% in Japanese fonts, for typesetting foreign words in the same style
% as the surrounding text.
%
% \begin{Xexample}[firstline=2]{charwdprop}{Proportional or fixed width forms.}
%   \def\texta{}\def\textb{}
%   \def\test{\makebox[2cm][l]{\texta}%
%             \makebox[2.5cm][l]{\textb}%
%             \makebox[2.5cm][l]{abcdef}}
%   \fontspec{Hiragino Mincho Pro}
%   {\addfontfeature{CharacterWidth=Proportional}\test}\\
%   {\addfontfeature{CharacterWidth=Full}\test}\\
%   {\addfontfeature{CharacterWidth=Half}\test}
% \end{Xexample}
%
% The same situation occurs with numbers, which are provided in
% increasingly illegible compressed forms seen in \exref{charwd}.
%
% \begin{Xexample}[firstline=2]{charwd}{Numbers can be compressed significantly.}
%   \centering
%   \fontspec[Renderer=AAT]{Hiragino Mincho Pro}
%   {\addfontfeature{CharacterWidth=Full}
%    ---12321---}\\
%   {\addfontfeature{CharacterWidth=Half}
%    ---1234554321---}\\
%   {\addfontfeature{CharacterWidth=Third}
%    ---123456787654321---}\\
%   {\addfontfeature{CharacterWidth=Quarter}
%    ---12345678900987654321---}
% \end{Xexample}
%
% \subsection{Vertical typesetting}
%
% TODO!
%
%
% \subsection{OpenType scripts and languages}\label{sec:ot}
%
% Fonts that include glyphs for various scripts and languages may contain different font features for the different character sets and languages they support, and different font features may behave differently depending on the script or language chosen.
% When multilingual fonts are used, it is important to select which language
% they are being used for, and more importantly what script is being used.
%
% The `script' refers to the alphabet in used; for example, both English
% and French use the Latin script. Similarly, the Arabic script can be used
% to write in both the Arabic and Persian languages.
%
% The
% \feat{Script} and \feat{Language} features are used to designate this information. The possible options are
% tabulated in \vref{tab:ot-scpt} and \vref{tab:ot-lang},
% respectively. When a script or language is requested that is not
% supported by the current font, a warning is printed in the console output.
%
% Because these font features can
% change which features are able to be selected for the font, they are automatically selected
% by \pkg{fontspec} before all others and, if \XeTeX\ is being used, will
% specifically select the \opt{ICU}
% renderer for this font, as described in \vref{sec:renderer}.
%
%
% \subsubsection{\feat{Script} and \feat{Language} examples}
%
% In the following examples, the Code2000 font\note{\url{http://www.code2000.net/}}
% is used to typeset the input with and without the OpenType Script
% applied. The text is only rendered correctly in the second case;
% many examples of incorrect diacritic spacing as
% well as a lack of contextual ligatures and rearrangement can be
% seen. Thanks to \name{Jonathan Kew}, \name{Yves Codet} and
% \name{Gildas Hamel} for their contributions towards these examples.
%
% \begin{Xexample}[firstline=14,lastline=23]{script-lang}{An example of various Scripts and Languages.}
% \def\testfeature#1#2{%^^A
%   \fontspec{\examplefont}#2 & \fontspec[#1]{\examplefont}#2\\[1ex]}
% \def \examplefont{Code2000}
% \def \arabictext{}
% \def \devanagaritext{}
% \def \bengalitext{}
% \def \gujaratitext{- }
% \def \malayalamtext{ }
% \def \gurmukhitext{   }
% \def \tamiltext{ }
% \def \hebrewtext{}
% \def \vietnamesetext{cp s mi}
% \begin{tabular}{r@{\quad}l}
%   \testfeature{Script=Arabic}{\arabictext}
%   \testfeature{Script=Devanagari}{\devanagaritext}
%   \testfeature{Script=Bengali}{\bengalitext}
%   \testfeature{Script=Gujarati}{\gujaratitext}
%   \testfeature{Script=Malayalam}{\malayalamtext}
%   \testfeature{Script=Gurmukhi}{\gurmukhitext}
%   \testfeature{Script=Tamil}{\tamiltext}
%   \testfeature{Script=Hebrew}{\hebrewtext}
%   \def\examplefont{Doulos SIL}
%   \testfeature{Language=Vietnamese}{\vietnamesetext}
% \end{tabular}
% \end{Xexample}
%
%
%
% \subsubsection{Defining new scripts and languages}
%
% \DescribeMacro{\newfontscript}
% \DescribeMacro{\newfontlanguage}
% While the scripts and languages listed in \ref{tab:ot-scpt} and \ref{tab:ot-lang}
% are intended to be comprehensive, there may be some missing; alternatively,
% you might wish to use different names to access scripts/languages that are
% already listed.
% Adding scripts and languages can be performed with the \cmd\newfontscript\
% and \cmd\newfontlanguage\ commands. For example,
% \begin{Verbatim}
%   \newfontscript{Arabic}{arab}
%   \newfontlanguage{Zulu}{ZUL}
% \end{Verbatim}
% The first argument is the \pkg{fontspec} name, the second the OpenType
% tag. The advantage to using these commands rather than \cmd\newfontfeature\
% (see \vref{sec:newfeatures}) is the error-checking that is performed when
% the script or language is requested.
%
% \begin{table}[!hbp]
%   \caption{Defined \opt{Script}s for OpenType fonts. Aliased names are shown in adjacent positions marked with red pilcrows ({\sffamily\textcolor{red}{\P}}).}
%   \label{tab:ot-scpt}
% \def\dup{\makebox[0pt][r]{\textcolor{red}{\P}}}
% \setlength\columnseprule{0pt}
%   \hrule
%   \begin{multicols}{4}\setlength\parindent{0pt}
%     \sffamily\scriptsize
%     Arabic \par Armenian \par Balinese \par Bengali \par Bopomofo \par Braille \par Buginese \par Buhid \par Byzantine Music \par Canadian Syllabics \par Cherokee \par \dup CJK \par \dup CJK Ideographic \par Coptic \par Cypriot Syllabary \par Cyrillic \par Default \par Deseret \par Devanagari \par Ethiopic \par Georgian \par Glagolitic \par Gothic \par Greek \par Gujarati \par Gurmukhi \par Hangul Jamo \par Hangul \par Hanunoo \par Hebrew \par \dup Hiragana and Katakana \par \dup Kana \par Javanese \par Kannada \par Kharosthi \par Khmer \par Lao \par Latin \par Limbu \par Linear B \par Malayalam \par \dup Math \par \dup Maths \par Mongolian \par Musical Symbols \par Myanmar \par N'ko \par Ogham \par Old Italic \par Old Persian Cuneiform \par Oriya \par Osmanya \par Phags-pa \par Phoenician \par Runic \par Shavian \par Sinhala \par Sumero-Akkadian Cuneiform \par Syloti Nagri \par Syriac \par Tagalog \par Tagbanwa \par Tai Le \par Tai Lu \par Tamil \par Telugu \par Thaana \par Thai \par Tibetan \par Tifinagh \par Ugaritic Cuneiform \par Yi
%   \end{multicols}
%   \hrule
% \end{table}
%
% \begin{table}[p]
%   \vspace*{-3cm}
%   \hspace{-3cm}
%   \def\dup{\makebox[0pt][r]{\textcolor{red}{\P}}}
%   \begin{minipage}{\linewidth+4cm}
%   \caption{Defined \opt{Language}s for OpenType fonts. Aliased names are shown in adjacent positions marked with red pilcrows ({\sffamily\textcolor{red}{\P}}).}
%   \label{tab:ot-lang}
%   \setlength\columnseprule{0pt}
%   \hrule
%   \begin{multicols}{6}
%     \everypar{\setlength\parindent{0pt}\setlength\hangindent{2em}}
%     \sffamily\footnotesize\raggedright
%     Abaza \par Abkhazian \par Adyghe \par Afrikaans \par Afar \par Agaw \par Altai \par Amharic \par Arabic \par Aari \par Arakanese \par Assamese \par Athapaskan \par Avar \par Awadhi \par Aymara \par Azeri \par Badaga \par Baghelkhandi \par Balkar \par Baule \par Berber \par Bench \par Bible Cree \par Belarussian \par Bemba \par Bengali \par Bulgarian \par Bhili \par Bhojpuri \par Bikol \par Bilen \par Blackfoot \par Balochi \par Balante \par Balti \par Bambara \par Bamileke \par Breton \par Brahui \par Braj Bhasha \par Burmese \par Bashkir \par Beti \par Catalan \par Cebuano \par Chechen \par Chaha Gurage \par Chattisgarhi \par Chichewa \par Chukchi \par Chipewyan \par Cherokee \par Chuvash \par Comorian \par Coptic \par Cree \par Carrier \par Crimean Tatar \par Church Slavonic \par Czech \par Danish \par Dargwa \par Woods Cree \par German \par Default \par Dogri \par Divehi \par Djerma \par Dangme \par Dinka \par Dungan \par Dzongkha \par Ebira \par Eastern Cree \par Edo \par Efik \par Greek \par English \par Erzya \par Spanish \par Estonian \par Basque \par Evenki \par Even \par Ewe \par French Antillean \par \dup Farsi \par \dup Parsi \par \dup Persian \par Finnish \par Fijian \par Flemish \par Forest Nenets \par Fon \par Faroese \par French \par Frisian \par Friulian \par Futa \par Fulani \par Ga \par Gaelic \par Gagauz \par Galician \par Garshuni \par Garhwali \par Ge'ez \par Gilyak \par Gumuz \par Gondi \par Greenlandic \par Garo \par Guarani \par Gujarati \par Haitian \par Halam \par Harauti \par Hausa \par Hawaiin \par Hammer-Banna \par Hiligaynon \par Hindi \par High Mari \par Hindko \par Ho \par Harari \par Croatian \par Hungarian \par Armenian \par Igbo \par Ijo \par Ilokano \par Indonesian \par Ingush \par Inuktitut \par Irish \par Irish Traditional \par Icelandic \par Inari Sami \par Italian \par Hebrew \par Javanese \par Yiddish \par Japanese \par Judezmo \par Jula \par Kabardian \par Kachchi \par Kalenjin \par Kannada \par Karachay \par Georgian \par Kazakh \par Kebena \par Khutsuri Georgian \par Khakass \par Khanty-Kazim \par Khmer \par Khanty-Shurishkar \par Khanty-Vakhi \par Khowar \par Kikuyu \par Kirghiz \par Kisii \par Kokni \par Kalmyk \par Kamba \par Kumaoni \par Komo \par Komso \par Kanuri \par Kodagu \par Korean Old Hangul \par Konkani \par Kikongo \par Komi-Permyak \par Korean \par Komi-Zyrian \par Kpelle \par Krio \par Karakalpak \par Karelian \par Karaim \par Karen \par Koorete \par Kashmiri \par Khasi \par Kildin Sami \par Kui \par Kulvi \par Kumyk \par Kurdish \par Kurukh \par Kuy \par Koryak \par Ladin \par Lahuli \par Lak \par Lambani \par Lao \par Latin \par Laz \par L-Cree \par Ladakhi \par Lezgi \par Lingala \par Low Mari \par Limbu \par Lomwe \par Lower Sorbian \par Lule Sami \par Lithuanian \par Luba \par Luganda \par Luhya \par Luo \par Latvian \par Majang \par Makua \par Malayalam Traditional \par Mansi \par Marathi \par Marwari \par Mbundu \par Manchu \par Moose Cree \par Mende \par Me'en \par Mizo \par Macedonian \par Male \par Malagasy \par Malinke \par Malayalam Reformed \par Malay \par Mandinka \par Mongolian \par Manipuri \par Maninka \par Manx Gaelic \par Moksha \par Moldavian \par Mon \par Moroccan \par Maori \par Maithili \par Maltese \par Mundari \par Naga-Assamese \par Nanai \par Naskapi \par N-Cree \par Ndebele \par Ndonga \par Nepali \par Newari \par Nagari \par Norway House Cree \par Nisi \par Niuean \par Nkole \par N'ko \par Dutch \par Nogai \par Norwegian \par Northern Sami \par Northern Tai \par Esperanto \par Nynorsk \par Oji-Cree \par Ojibway \par Oriya \par Oromo \par Ossetian \par Palestinian Aramaic \par Pali \par Punjabi \par Palpa \par Pashto \par Polytonic Greek \par Pilipino \par Palaung \par Polish \par Provencal \par Portuguese \par Chin \par Rajasthani \par R-Cree \par Russian Buriat \par Riang \par Rhaeto-Romanic \par Romanian \par Romany \par Rusyn \par Ruanda \par Russian \par Sadri \par Sanskrit \par Santali \par Sayisi \par Sekota \par Selkup \par Sango \par Shan \par Sibe \par Sidamo \par Silte Gurage \par Skolt Sami \par Slovak \par Slavey \par Slovenian \par Somali \par Samoan \par Sena \par Sindhi \par Sinhalese \par Soninke \par Sodo Gurage \par Sotho \par Albanian \par Serbian \par Saraiki \par Serer \par South Slavey \par Southern Sami \par Suri \par Svan \par Swedish \par Swadaya Aramaic \par Swahili \par Swazi \par Sutu \par Syriac \par Tabasaran \par Tajiki \par Tamil \par Tatar \par TH-Cree \par Telugu \par Tongan \par Tigre \par Tigrinya \par Thai \par Tahitian \par Tibetan \par Turkmen \par Temne \par Tswana \par Tundra Nenets \par Tonga \par Todo \par Turkish \par Tsonga \par Turoyo Aramaic \par Tulu \par Tuvin \par Twi \par Udmurt \par Ukrainian \par Urdu \par Upper Sorbian \par Uyghur \par Uzbek \par Venda \par Vietnamese \par Wa \par Wagdi \par West-Cree \par Welsh \par Wolof \par Tai Lue \par Xhosa \par Yakut \par Yoruba \par Y-Cree \par Yi Classic \par Yi Modern \par Chinese Hong Kong \par Chinese Phonetic \par Chinese Simplified \par Chinese Traditional \par Zande \par Zulu
%   \end{multicols}
%   \hspace{4pt}
%   \hrule
%  \end{minipage}
% \end{table}
%
%
%
% \part{\LuaTeX-only font features}
% \label{sec:luatex-features}
%
% \section{OpenType font feature files}
%
% An OpenType font feature file is a plain text file describing OpenType layout
% feature of a font in a human-readable format. The syntax of OpenType feature
% files is defined by Adobe\note{\url{http://www.adobe.com/devnet/opentype/afdko/topic_feature_file_syntax.html}}.
%
% Feature files can be used to add or customize OpenType features of a font on
% the fly without editing the font file itself.
%
% Adding a new OpenType feature is as creating a plain text file defining
% the new feature and then loading it by passing its name or path to
% \feat{FeatureFile}, then OpenType features defined in the file can be
% activated as usual.
%
% For example, when adding one of the default features like \texttt{kern}
% or \texttt{liga}, no special activation is needed. On the other hand,
% an optional feature like \texttt{onum} or \texttt{smcp} will be
% activated when old style numbers or small capitals are activated,
% respectively. However, OpenType feature in the feature file can have any
% and that can be used to selectively activate the feature; for example
% defining a ligature feature called \texttt{mlig} and then activating it
% using \feat{RawFeature} option without activating other ligatures in the
% font.
%
% Figure~\ref{fig:featurefile} shows an example feature file. The first two
% lines set the script and language under which the defined features will be
% available, which the default language in both default and Latin scripts,
% respectively.
%
% Then it defines a \texttt{liga} feature, which is a glyph substitution
% feature. The names starting with backslash are glyph names that is to be
% substituted and while the leading backslash is optional, it is used to
% escape glyph names when they interfere with preserved keywords. It should
% also be noted that glyph names are font specific and the same glyph can be
% named differently in different fonts.
%
% Glyph positioning features like kerning can be defined in a similar way,
% but instead of the keyword \texttt{sub(stitute)} the keyword
% \texttt{pos(ition)} is used instead. Figure~\ref{fig:featurefile} shows
% an example of adding kerning between \texttt{AY} and \texttt{ay}\note{
% The kerning is expressed in font design units which are fractions of em
% depending on the \emph{units per em} value of the font, usually 1000 for
% PostScript fonts and 2048 for TrueType fonts.}.
%
% Lines starting with \verb|#| are comments and will be ignored.
%
% An OpenType feature file can have any number of features and can have a
% mix of substitution and positioning features, please refer to the full
% feature file specification for further documentation.
%
% \begin{figure}
% \caption{An example font feature file.}
% \label{fig:featurefile}
% \hrule
% \begin{Verbatim}
% languagesystem DFLT dflt;
% languagesystem latn dflt;
%
% # Ligatures
% feature liga {
%   sub \f \i by \fi;
%   sub \f \l by \fl;
% } liga;
%
% # Kerning
% feature kern {
%  pos \A \Y -200;
%  pos \a \y -80;
% } kern;
% \end{Verbatim}
% \hrule
% \end{figure}
%
% \part{Fonts and features with \XeTeX}
% \label{sec:xetex-features}
%
%
%
%
% \section{\XeTeX-only font features}
%
% The features described here are available for any font
% selected by \pkg{fontspec}.
%
% \subsection{Mapping}
% \label{sec:mapping}
%
% \feat{Mapping} enables a \XeTeX\ text-mapping scheme, shown in \exref{mapping}.
%
% \begin{Xexample}{mapping}{\XeTeX's \feat{Mapping} feature.}
%   \fontspec[Mapping=tex-text]{Cochin}
%   ``!`A small amount of---text!''
% \end{Xexample}
%
% Using the |tex-text| mapping is also equivalent to writing |Ligatures=TeX|.
% The use of the latter syntax is recommended for better compatibility with
% \LuaTeX\ documents.
%
%
% \subsection{Letter spacing}
% Letter spacing, or tracking, is the term given to adding (or subtracting) a small amount of horizontal space in between adjacent characters. It is specified with the \feat{LetterSpace}, which takes a numeric argument,
% shown in \exref{tracking}.
%
% The letter spacing parameter is a normalised additive factor (not a scaling factor); it is defined as a percentage of the font size. That is, for a 10\,pt font, a letter spacing parameter of `|1.0|' will add 0.1\,pt between each letter.
%
% \begin{Xexample}{tracking}{The \feat{LetterSpace} feature.}
%   \fontspec{Didot}
%   \addfontfeature{LetterSpace=0.0}
%   USE TRACKING FOR DISPLAY CAPS TEXT \\
%   \addfontfeature{LetterSpace=2.0}
%   USE TRACKING FOR DISPLAY CAPS TEXT
% \end{Xexample}
%
% This functionality \emph{should not be used for lowercase text}, which is spacing correctly to begin with, but it can be very useful, in small amounts, when setting small caps or all caps titles.
% Also see the OpenType \opt{Uppercase}
% option of the \feat{Letters} feature (\vref*{sec:letters}).
%
% \subsection{Different font technologies: \AAT\ and \ICU}\label{sec:renderer}
%
% \XeTeX\ supports two rendering technologies for typesetting, selected with
% the \feat{Renderer} font feature. The first, \opt{AAT}, is
% that provided (only) by \MacOSX\ itself. The second, \opt{ICU},
% is an open source OpenType interpreter. It provides much greater support for
% OpenType features, notably contextual arrangement, over \opt{AAT}.
%
% In general, this feature will not need to be explicitly called: for OpenType
% fonts, the \opt{ICU} renderer is used automatically, and for \AAT\ fonts,
% \opt{AAT} is chosen by default. Some fonts, however, will contain font tables
% for \emph{both} rendering technologies, such as the Hiragino Japanese fonts
% distributed with \MacOSX, and in these cases the choice may be required.
%
% Among some other font features only available through a specific renderer,
% \opt{ICU} provides for the \feat{Script} and \feat{Language} features, which allow
% different font behaviour for different alphabets and languages; see \vref{sec:ot}
% for the description of these features. {\em Because these font features can
% change which features are able to be selected for the font instance, they are selected
% by \pkg{fontspec} before all others and will automatically and without warning
% select the \opt{ICU} renderer.}
%
%
% \subsection{Optical font sizes} \label{sec:aat-opticalsize}
%
% Multiple Master fonts are parameterised over
% orthogonal font axes, allowing continuous selection along such
% features as weight, width, and optical size~(see \vref{sec:mm} for
% further details). Whereas an OpenType font will have only a few separate
% optical sizes, a Multiple Master font's optical size can be
% specified over a continuous range. Unfortunately, this flexibility makes
% it harder to create an automatic interface through \LaTeX, and the
% optical size for a Multiple Master font must always be specified
% explicitly.
% \begin{Verbatim}
%   \fontspec[OpticalSize=11]{Minion MM Roman}
%    MM optical size test                    \\
%   \fontspec[OpticalSize=47]{Minion MM Roman}
%    MM optical size test                    \\
%   \fontspec[OpticalSize=71]{Minion MM Roman}
%    MM optical size test                    \\
% \end{Verbatim}
%
%
%
%
% \section{\MacOSX's \AAT\ fonts}
% \label{sec:aat-features}
%
% \MacOSX's font technology began life before the ubiquitous-OpenType era
% and revolved around the Apple-invented `\AAT' font format. This format
% had some advantages (and other disadvantages) but it never became widely
% popular in the font world.
%
% Nonetheless, this is the font format that was first supported by \XeTeX\
% (due to its pedigree on \MacOSX\ in the first place) and was the first
% font format supported by \pkg{fontspec}. A number of fonts distributed with
% \MacOSX\ are still in the \AAT\ format, such as `Skia'. Documents
% that use these fonts should be compiled with \XeLaTeX\ using the
% \texttt{xdv2pdf} driver, as opposed to the default \texttt{xdvipdfmx}. E.g.,
% \begin{verbatim}
%   xelatex -output-driver="xdv2pdf" filename.tex
% \end{verbatim}
%
% \MacOSX\ also supports Multiple Master fonts, which are discussed
% in \ref{sec:mm}.
%
% \subsection{Ligatures}
%
% \feat{Ligatures} refer to the replacement of two separate characters
% with a specially drawn glyph for functional or \ae sthetic reasons.
% For \AAT\ fonts, you may choose from any combination of \opt{Required},
% \opt{Common}, \opt{Rare} (or \opt{Discretionary}), \opt{Logos}, \opt{Rebus},
% \opt{Diphthong}, \opt{Squared}, \opt{AbbrevSquared}, and \opt{Icelandic}.
%
% Some other Apple \AAT\ fonts have those `Rare' ligatures contained in
% the \opt{Icelandic} feature. Notice also that the old \TeX\ trick of
% splitting up a ligature with an empty brace pair does not work in
% \XeTeX; you must use a 0\,pt kern or \cs{hbox} (\eg, \cs{null}) to
% split the characters up if you do not want a ligature to be performed (the usual examples for when this might be desired are words like `shelf\null full').
%
% \subsection{Letters} \label{sec:aat-letters}
% The \opt{Letters} feature specifies how the letters in the current font
% will look. For \AAT\ fonts, you may choose from \opt{Normal},
% \opt{Uppercase}, \opt{Lowercase}, \opt{SmallCaps}, and
% \opt{InitialCaps}.
%
%
% \subsection{Numbers}
% The \feat{Numbers} feature defines how numbers will look in the
% selected font. For \AAT\ fonts, they may be a
% combination of \opt{Lining} or \opt{OldStyle} and \opt{Proportional} or
% \opt{Monospaced} (the latter is good for tabular material). The synonyms
% \opt{Uppercase} and \opt{Lowercase} are equivalent to \opt{Lining} and
% \opt{OldStyle}, respectively. The differences have been shown previously
% in \vref{sec:addfontfeatures}.
%
% \subsection{Contextuals} \label{sec:contextuals}
% This feature refers to glyph substitution that vary by their position;
% things like contextual swashes are implemented here
% The options for \AAT\ fonts are
% \opt{WordInitial}, \opt{WordFinal} (\exref{wordcx}), \opt{LineInitial},
% \opt{LineFinal}, and \opt{Inner} (\exref{longsaat}, also called `non-final' sometimes). As
% non-exclusive selectors, like the ligatures, you can turn them off
% by prefixing their name with \opt{No}.
%
% \begin{Xexample}{wordcx}{Contextual glyph for the beginnings and ends of words.}
%   \newfontface\fancy
%       [Contextuals={WordInitial,WordFinal}]
%                        {Hoefler Text Italic}
%   \fancy where is all the vegemite
% \end{Xexample}
%
% \begin{Xexample}{longsaat}{A contextual feature for the `long s' can be convenient as the character does not need to be marked up explicitly.}
%   \fontspec[Contextuals=Inner]{Hoefler Text}
%   `Inner' swashes can \emph{sometimes}    \\
%    contain the archaic long~s.
% \end{Xexample}
%
%
%
% \subsection{Vertical position}
% The \feat{VerticalPosition} feature is used to access things like
% subscript (\opt{Inferior}) and superscript (\opt{Superior}) numbers and
% letters (and a small amount of punctuation, sometimes).
% The \opt{Ordinal} option is (supposed to be)
% contextually sensitive to only raise characters that appear directly
% after a number.
% These are shown in \exref{aat-supp}.
%
% \begin{Xexample}{aat-supp}{Vertical position for AAT fonts.}
%   \fontspec{Skia}
%    Normal
%   \fontspec[VerticalPosition=Superior]{Skia}
%    Superior
%   \fontspec[VerticalPosition=Inferior]{Skia}
%    Inferior                \\
%   \fontspec[VerticalPosition=Ordinal]{Skia}
%    1st 2nd 3rd 4th 0th 8abcde
% \end{Xexample}
%
% The \pkg{realscripts} package
% (also loaded by \pkg{xltxtra})
% redefines the \cmd\textsubscript\ and
% \cmd\textsuperscript\ commands to use the above font features,
% including for use in footnote labels.
%
% \subsection{Fractions}
% Many fonts come with the capability to typeset various forms of
% fractional material. This is accessed in \pkg{fontspec} with the
% \feat{Fractions} feature, which may be turned \opt{On} or \opt{Off}
% in both \AAT\ and OpenType fonts.
%
% In \AAT\ fonts, the `fraction slash' or solidus character, is
% to be used to create fractions. When \feat{Fractions} are turned
% \opt{On}, then only pre-drawn fractions will be used.
% See \exref{aat-frac}.
%
% Using the \opt{Diagonal} option (\AAT\ only), the font will attempt
% to create the fraction from superscript and subscript
% characters.
%
% \edef\caretcc{\the\catcode`\^}
% \catcode`\^=12\relax
% \begin{Xexample}{aat-frac}{Fractions in AAT fonts. The \texttt{\relax^^^^2044} glyph is the `fraction slash' that may be typed in \MacOSX\ with \textsc{opt+shift+1}; not shown literally here due to font contraints.}
%   \fontspec[Fractions=On]{Skia}
%    1{^^^^2044}2 \quad 5{^^^^2044}6 \\ % fraction slash
%    1/2 \quad 5/6    % regular  slash
%
%   \fontspec[Fractions=Diagonal]{Skia}
%          13579{^^^^2044}24680 \\ % fraction slash
%    \quad 13579/24680    % regular  slash
% \end{Xexample}
% \catcode`\^=\caretcc\relax
%
% Some (Asian fonts predominantly) also provide for the
% \opt{Alternate} feature shown in \exref{frac-alt}.
%
% \begin{Xexample}{frac-alt}{Alternate design of pre-composed fractions.}
%   \fontspec{Hiragino Maru Gothic Pro}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680 \\
%   \addfontfeature{Fractions=Alternate}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680
% \end{Xexample}
%
%
% \subsection{Variants}
% The \feat{Variant} feature takes a single numerical input for
% choosing different alphabetic shapes. Don't mind my fancy \exref{aat-var}
% \texttt{:)} I'm just looping through the nine~(\,!\,) variants of
% Zapfino.
%
% \begin{Xexample}[firstline=2,lastline=9]{aat-var}{Nine variants of Zapfino.}
%   \Huge \rule{0pt}{2cm}
%   \newcounter{var}\newcounter{trans}
%   \whiledo{\value{var}<9}{%
%     \stepcounter{trans}%
%     \edef\1{%
%     \noexpand\fontspec[Variant=\thevar,
%       Color=005599\thetrans\thetrans]{Zapfino}}\1%
%     \makebox[0.75\width]{d}%
%     \stepcounter{var}}
%   \hspace*{2cm}
% \end{Xexample}
%
% See \vref{sec:newfeatures} for a way to assign names to variants,
% which should be done on a per-font basis.
%
% \subsection{Alternates}
%
% Selection of \feat{Alternate}s \emph{again}
% must be done numerically; see \exref{aat-alt}.
% See \vref{sec:newfeatures} for a way to assign names to alternates,
% which should be done on a per-font basis.
%
% \begin{Xexample}{aat-alt}{Alternate shape selection must be numerical.}
%   \fontspec[Alternate=0]{Hoefler Text Italic}
%    Sphinx Of Black Quartz, {\scshape Judge My Vow} \\
%   \fontspec[Alternate=1]{Hoefler Text Italic}
%    Sphinx Of Black Quartz, {\scshape Judge My Vow}
% \end{Xexample}
%
%
% \subsection{Style}
%
% The options of the \feat{Style} feature
% are defined in \AAT\ as one of the following: \opt{Display},
% \opt{Engraved}, \opt{IlluminatedCaps}, \opt{Italic},
% \opt{Ruby},\footnotemark\ \opt{TallCaps}, or \opt{TitlingCaps}.
% \footnotetext{`Ruby' refers to a small optical size, used in
% Japanese typography for annotations.}
%
% Typical examples for these features are shown in \ref{sec:ot-feat-style}.
%
%
%
%
%
%
% \subsection{CJK shape}
% There have been many standards for how CJK ideographic
% glyphs are `supposed' to look. Some fonts will contain many alternate
% glyphs in order to be able to display these gylphs
% correctly in whichever form is appropriate. Both \AAT\ and OpenType
% fonts support the following \feat{CJKShape} options:
% \opt{Traditional}, \opt{Simplified}, \opt{JIS1978}, \opt{JIS1983},
% \opt{JIS1990}, and \opt{Expert}. OpenType also supports the \opt{NLC} option.
%
% \subsection{Character width}
% See \vref{sec:CharacterWidth} for relevant examples; the features are
% the same between OpenType and \AAT\ fonts.
% \AAT\ also allows \feat{CharacterWidth}|=|\opt{Default} to return to
% the original font settings.
%
%


%
%
%
% \subsection{Vertical typesetting}
%
% TODO: improve!
%
% \XeTeX\ provides for vertical typesetting simply with the ability to rotate
% the individual glyphs as a font is used for typesetting, as shown in
% \exref{vert}.
%
% \begin{Xexample}[firstline=2]{vert}{Vertical typesetting.}
%   \def\verttext{}
%   \fontspec{Hiragino Mincho Pro}
%   \verttext
%
%   \fontspec[Renderer=AAT,Vertical=RotatedGlyphs]{Hiragino Mincho Pro}
%   \rotatebox{-90}{\verttext}% requires the graphicx package
% \end{Xexample}
%
% No actual provision is made for typesetting top-to-bottom
% languages; for an example of how to do this, see the vertical Chinese
% example provided in the \XeTeX\ documentation.
%
%
%
%
% \subsection{Diacritics}
% Diacritics are marks, such as the acute accent or the tilde, applied to letters; they usually indicate a change in pronunciation.
% In Arabic scripts, diacritics are used to indicate vowels.
% You may either choose
% to \opt{Show}, \opt{Hide} or \opt{Decompose} them in \AAT\ fonts.
% The \opt{Hide} option is for scripts such as Arabic which may be
% displayed either with or without vowel markings. E.g.,
% \verb|\fontspec[Diacritics=Hide]{...}|
%
% Some older fonts distributed with \MacOSX\ included `|O/|' \etc\ as shorthand for writing `\O' under the label of the \feat{Diacritics} feature. If you come across such fonts, you'll
% want to turn this feature off (imagine typing |hello/goodbye| and
% getting `hell\o goodbye' instead!) by decomposing the two characters
% in the diacritic into the ones you actually
% want. I recommend using
% the proper \LaTeX\ input conventions for obtaining such characters
% instead.
%
%
%
% \subsection{Annotation}
% Various Asian fonts are equipped with a more extensive range of
% numbers and numerals in different forms. These are accessed through
% the \feat{Annotation} feature (see \exref{aat-annot}) with the following
% options: \opt{Off},
% \opt{Box}, \opt{RoundedBox}, \opt{Circle}, \opt{BlackCircle},
% \opt{Parenthesis}, \opt{Period}, \opt{RomanNumerals}, \opt{Diamond},
% \opt{BlackSquare}, \opt{BlackRoundSquare}, and \opt{DoubleCircle}.
%
% \begin{Xexample}{aat-annot}{Various annotation forms.}
%   \fontspec{Hei Regular}
%    1 2 3 4 5 6 7 8 9                         \\
%   \fontspec[Annotation=Circle]{Hei Regular}
%    1 2 3 4 5 6 7 8 9                         \\
%   \fontspec[Annotation=Parenthesis]{Hei Regular}
%    1 2 3 4 5 6 7 8 9                         \\
%   \fontspec[Annotation=Period]{Hei Regular}
%    1 2 3 4 5 6 7 8 9
% \end{Xexample}
%
% \section{\AAT\ \& Multiple Master font axes} \label{sec:mm}
%
% Multiple Master and \AAT\ font specifications both provide continuous
% variation along font parameters. For example, they don't have just
% regular and bold weights, they can have any bold weight you like between
% the two extremes.
%
% \opt{Weight}, \opt{Width}, and \opt{OpticalSize} are supported by this
% package. Skia, which is distributed with
% Mac~OS~X, has two of these variable parameters, allowing for the
% demonstration in \exref{aatmm}.
% Variations along a multiple master font's optical size axis has been
% shown previously in \vref{sec:opticalsize}.
%
% \begin{Xexample}{aatmm}{Continuously variable font parameters. These fonts
%  are unfortunately quite rare.}
%   \fontspec[Weight=0.5,Width=3]{Skia}
%    Really light and extended Skia         \\
%   \fontspec[Weight=2,Width=0.5]{Skia}
%    Really fat and condensed Skia
% \end{Xexample}
%
%
% \part{Programming interface}
%
% This is the beginning of some work to provide some hooks that use
% \pkg{fontspec} for various macro programming purposes.
%
%
% \section{Defining new features} \label{sec:newfeatures}
% This package cannot hope to contain every possible font
% feature. Three commands are provided for selecting font features
% that are not provided for out of the box. If you are using
% them a lot, chances are I've left something out, so please let me
% know.
%
% \DescribeMacro{\newAATfeature}
% New \AAT\ features may be created with this command:\par
% {\centering\cmd\newAATfeature\marg{feature}\marg{option}\marg{feature code}\marg{selector code}\par}\noindent
% Use the \XeTeX\ file \path{AAT-info.tex} to obtain the code numbers.
% See \exref{newAATfeat}.
%
% \begin{Xexample}{newAATfeat}{Assigning new \AAT\ features.}
%   \newAATfeature{Alternate}{HoeflerSwash}{17}{1}
%   \fontspec[Alternate=HoeflerSwash]{Hoefler Text Italic}
%    This is XeTeX by Jonathan Kew.
% \end{Xexample}
%
%
% \DescribeMacro{\newICUfeature}
% \DescribeMacro{\newopentypefeature}
% New OpenType features may be created with this command:\par
% {\centering\cmd\newICUfeature\marg{feature}\marg{option}\marg{feature tag}\par}
% The synonym \cs{newopentypefeature} is provided for \LuaLaTeX\ users.
%
% Here's what it would look like in practise:
% \begin{Verbatim}
% \newopentypefeature{Style}{NoLocalForms}{-locl}
% \end{Verbatim}
%
% \DescribeMacro{\newfontfeature}
% In case the above commands do not accommodate the desired font feature
% (perhaps a new \XeTeX\ feature that \pkg{fontspec} hasn't been updated
% to support), a command is provided to pass arbitrary input into the
% font selection string:\par
% {\centering\cmd{\newfontfeature}\marg{name}\marg{input string}\par}
%
% For example, Zapfino
% contains the feature `Avoid d-collisions'. To access it
% with this package, you could do some like that shown in \exref{avoidd}
%
% \begin{Xexample}{avoidd}{Assigning new arbitary features.}
%   \newfontfeature{AvoidD}{Special=Avoid d-collisions}
%   \newfontfeature{NoAvoidD}{Special=!Avoid d-collisions}
%   \fontspec[AvoidD,Variant=1]{Zapfino}
%    sockdolager rubdown               \\
%   \fontspec[NoAvoidD,Variant=1]{Zapfino}
%    sockdolager rubdown
% \end{Xexample}
%
% The advantage to using the \cmd\newAATfeature\ and \cmd\newICUfeature\
% commands instead of \cs{newfontfeature} is that they check if the selected font actually contains the desired font
% feature at load time. By contrast, \cmd\newfontfeature\ will not give a warning
% for improper input.
%
% \section{Going behind \pkg{fontspec}'s back}
% Expert users may wish not to use \pkg{fontspec}'s feature handling at all,
% while still taking advantage of its \LaTeX\ font selection conveniences. The
% \feat{RawFeature} font feature allows literal \XeTeX\ font feature selection
% when you happen to have the OpenType feature tag memorised.
%
% \begin{Xexample}{raw}{Using raw font features directly.}
%   \fontspec[RawFeature=+smcp]{TeX Gyre Pagella}
%   Pagella small caps
% \end{Xexample}
%
% Multiple features can either be included in a single declaration:\par
% {\centering|[RawFeature=+smcp;+onum]|\par}
% \noindent or with multiple declarations:\par
% {\centering|[RawFeature=+smcp, RawFeature=+onum]|\par}
%
% \section{Renaming existing features \& options}
% \label{sec:aliasfontfeature}
%
% \DescribeMacro{\aliasfontfeature}
% If you don't like the name of a particular font feature,
% it may be aliased to another with the
% \cs{aliasfontfeature}\marg{existing name}\marg{new name} command,
% such as shown in \exref{alias}.
%
% \begin{Xexample}{alias}{Renaming font features.}
%   \aliasfontfeature{ItalicFeatures}{IF}
%   \fontspec[IF = {Alternate=1}]{Hoefler Text}
%   Roman Letters \itshape And Swash
% \end{Xexample}
%
% Spaces in feature (and option names, see below) \emph{are} allowed. (You may have
% noticed this already in the lists of OpenType scripts and languages).
%
% \DescribeMacro{\aliasfontfeatureoption}
% If you wish to change the name of a font feature option,
% it can be aliased to another with the command
% \cs{aliasfontfeatureoption}\marg{font feature}\marg{existing name}\marg{new name}, such as shown in \exref{aliasopt}.
%
% \begin{Lexample}{aliasopt}{Renaming font feature options.}
%   \aliasfontfeature{VerticalPosition}{Vert Pos}
%   \aliasfontfeatureoption{VerticalPosition}{ScientificInferior}{Sci Inf}
%   \fontspec[Vert Pos=Sci Inf]{Linux Libertine}
%    Scientific Inferior: 12345
% \end{Lexample}
%
% This example demonstrates an important point: when aliasing the feature
% options, the \emph{original} feature name must be used when declaring
% to which feature the option belongs.
%
% Only feature options that exist as sets of fixed strings may be altered in
% this way. That is, \opt{Proportional} can be aliased to \opt{Prop} in the
% \feat{Letters} feature, but \opt{550099BB} cannot be substituted for \opt{Purple}
% in a \feat{Color} specification. For this type of thing, the \cmd\newfontfeature\
% command should be used to declare a new, \eg, \feat{PurpleColor} feature:
% \begin{Verbatim}
%   \newfontfeature{PurpleColor}{color=550099BB}
% \end{Verbatim}
% Except that this example was written before support for named colours was
% implemented. But you get the idea.
%
% \section{Programming details}
%
% In some cases, it is useful to know what the \LaTeX\ font family
% of a specific \pkg{fontspec} font is. After a \cmd\fontspec-like
% command, this is stored inside the \cmd\zf@family\ macro.
% Otherwise, \LaTeX's own \cmd\f@family\ macro can be useful here,
% too.
% The raw \TeX\ font that is defined is stored temporarily
% in \cmd{\zf@basefont}.
%
% The following commands in \pkg{expl3} syntax may be used
% for writing codes that interface with fontspec-loaded fonts.
% All of the following conditionals also exist with |T| and |F|
% suffices as well as |TF|.
%
% \begin{macro}{\fontspec_if_fontspec_font:TF}
% Test whether the currently selected font has been loaded by fontspec.
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_aat_feature:nnTF}
% Test whether the currently selected font contains the \AAT\
% feature (|#1|,|#2|).
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_opentype:TF}
% Test whether the currently selected font is an OpenType font.
% Always true for LuaTeX fonts.
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nTF}
% Test whether the currently selected font contains the raw OpenType
% feature |#1|. E.g.: |\fontspec_if_feature:nTF {pnum} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nnnTF}
% Test whether the currently selected font with raw OpenType script tag |#1| and raw OpenType language tag |#2| contains the raw OpenType feature tag |#3|. E.g.: |\fontspec_if_feature:nTF {latn} {ROM} {pnum} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
% \begin{macro}{\fontspec_if_script:nTF}
% Test whether the currently selected font contains the raw OpenType
% script |#1|. E.g.: |\fontspec_if_script:nTF {latn} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#1|. E.g.: |\fontspec_if_language:nTF {ROM} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nnTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#2| in script |#1|. E.g.: |\fontspec_if_language:nnTF {cyrl} {SRB} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_current_script:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType script tag |#1|.
% \end{macro}
%
% \begin{macro}{\fontspec_if_current_language:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType language tag |#1|.
% \end{macro}
%
% \begin{macro}{\fontspec_set_family:Nnn}
% \darg{family}
% \darg{fontspec features}
% \darg{font name}
% Defines a new font family from given \meta{features} and \meta{font},
% and stores the name in the variable \meta{family}.
% See the standard \pkg{fontspec} user commands for applications of this
% function.
% \end{macro}
%
%  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \part{The patching/improvement of \LaTeXe\ and other packages}
% \label{sec:patching}
%
% Derived originally from xltxtra, this package contains patches to various
% \LaTeX\ components and third-party packages to improve the default
% behaviour.
%
% \section{Inner emphasis}
% \label{sec:emph}
%
% \pkg{fixltx2e}'s method for checking for ``inner'' emphasis is a little fragile in \XeTeX, because
% font slant information might be missing from the font. Therefore, we use \LaTeX's NFSS
% information, which is more likely to be correct.
%
% \section{Unicode footnote symbols}
% By default \LaTeX\ defines symbolic footnote characters in terms of commands
% that don't resolve well; better results can be achieved by using specific Unicode characters or proper LICRs with the \pkg{xunicode} package.
%
% This problem has been solved by loading the \pkg{fixltx2e} package.
%
% \section{Verbatim}
% \label{sec:verb}
%
% Many verbatim mechanisms assume the existence of a `visible space' character that exists in the \textsc{ascii} space slot of the typewriter font. This character is known in Unicode as \unichar{2434}{box open}, which looks like this: `\verb*| |'.
%
% When a Unicode typewriter font is used, \LaTeX\ no longer prints visible spaces for the |verbatim*| environment and |\verb*| command. This problem is fixed by using the correct Unicode glyph, and the following packages are patched to do the same:
% \pkg{listings}, \pkg{fancyvrb}, \pkg{moreverb}, and \pkg{verbatim}.
%
% In the case that the typewriter font does not contain `\verb*| |', the Latin Modern Mono font is used as a fallback.
%
% \section{Discretionary hyphenation: \cmd\-}
% \label{sec:hyphen}
%
% \LaTeX\ defines the macro \cmd\-\ to insert discretionary hyphenation points.
% However, it is hard-coded in \LaTeX\ to use the hyphen |-| character. Since \pkg{fontspec}
% makes it easy to change the hyphenation character on a per font basis, it would
% be nice if \cmd\-\ adjusted automatically --- and now it does.
%
% \StopEventually{}
%
% \clearpage
% \part{fontspec.sty}
%
% \section{Implementation}
% Herein lie the implementation details of this package. Welcome!
% It was my first.
%
% For some reason, I decided to prefix all the package internal
% command names and variables with |zf|. I don't know why I chose
% those letters, but I guess I just liked the look/feel of them
% together at the time. (Possibly inspired by Hermann \emph{Z}ap\emph{f}.)
%
% \iffalse
%<*fontspec>
% \fi
%    \begin{macrocode}
\RequirePackage{expl3,xparse}
\input binhex.tex  % before expl syntax!
\ExplSyntaxOn
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn {fontspec} {not-pdftex}
{
  Requires~ XeTeX~ or~ LuaTeX~ to~ function!
}
\xetex_if_engine:F {
  \luatex_if_engine:TF {
    \RequirePackage{luatextra}[2010/05/10]
    \luatexRequireModule{fontspec}
  }{
    \msg_fatal:nn {fontspec} {not-pdftex}
  }
}
%    \end{macrocode}
%
% \begin{macro}{\xetex_or_luatex:nn}
% Use |#1| if \XeTeX\ or |#2| if \LuaTeX.
%    \begin{macrocode}
\xetex_if_engine:TF
  { \cs_new_eq:NN \xetex_or_luatex:nn \use_i:nn }
  { \luatex_if_engine:T
    { \cs_new_eq:NN \xetex_or_luatex:nn \use_ii:nn }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xetex_or_luatex:nnn}
% Use |#1| and (|{#2}| if \XeTeX) or (|{#3}| if \LuaTeX).
%    \begin{macrocode}
\xetex_if_engine:TF
  { \cs_new:Npn \xetex_or_luatex:nnn #1#2#3 {#1{#2}} }
  {
    \luatex_if_engine:T
     { \cs_new:Npn \xetex_or_luatex:nnn #1#2#3 {#1{#3}} }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Bits and pieces}
% \paragraph{Conditionals}
%    \begin{macrocode}
\bool_new:N \l_fontspec_firsttime_bool
\bool_new:N \l_fontspec_nobf_bool
\bool_new:N \l_fontspec_noit_bool
\bool_new:N \l_fontspec_nosc_bool
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_new:N \l_fontspec_tfm_bool
\bool_new:N \l_fontspec_atsui_bool
\bool_new:N \l_fontspec_icu_bool
\bool_new:N \l_fontspec_mm_bool
\bool_new:N \l_fontspec_graphite_bool
%    \end{macrocode}
% For dealing with legacy maths
%    \begin{macrocode}
\bool_new:N \g_fontspec_math_euler_bool
\bool_new:N \g_fontspec_math_lucida_bool
\bool_new:N \g_fontspec_package_euler_loaded_bool
%    \end{macrocode}
% For package options:
%    \begin{macrocode}
\bool_new:N \g_fontspec_cfg_bool
\bool_new:N \g_fontspec_math_bool
%    \end{macrocode}
% \paragraph{Counters}
%    \begin{macrocode}
\int_new:N \l_fontspec_script_int
\int_new:N \l_fontspec_language_int
\int_new:N \l_fontspec_strnum_int
%    \end{macrocode}
% Temporary definition until expl3 has been updated to include this:
%    \begin{macrocode}
\cs_set:Npn \use:x #1 { \edef\@tempa{#1}\@tempa }

\cs_if_exist:NF \str_if_eq:xxTF {
  \cs_set_eq:NN \str_if_eq_p:xx \tl_if_eq_p:xx
  \cs_set_eq:NN \str_if_eq:xxTF \tl_if_eq:xxTF
  \cs_set_eq:NN \str_if_eq:xxT  \tl_if_eq:xxT
  \cs_set_eq:NN \str_if_eq:xxF  \tl_if_eq:xxF
  \cs_set_eq:NN \str_if_eq_p:nn \tl_if_eq_p:nn
  \cs_set_eq:NN \str_if_eq:nnTF \tl_if_eq:nnTF
  \cs_set_eq:NN \str_if_eq:nnT \tl_if_eq:nnT
  \cs_set_eq:NN \str_if_eq:nnF \tl_if_eq:nnF
}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set:Npn \use_v:nnnnn #1#2#3#4#5 {#5}
\cs_set:Npn \use_iv:nnnnn #1#2#3#4#5 {#4}
%    \end{macrocode}
%
% Need these:
%    \begin{macrocode}
\cs_generate_variant:Nn \str_if_eq:nnTF {nv}
\cs_generate_variant:Nn \int_set:Nn {Nv}
\cs_generate_variant:Nn \tl_gset:Nn {cV}
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cs_new:Npn \fontspec_setkeys:xx #1#2
 {
  \use:x { \exp_not:N \setkeys*[zf]{#1}{#2} }
 }
\cs_new:Npn \fontspec_setkeys:xxx #1#2#3
 {
  \use:x { \exp_not:N \setkeys*[zf@#1]{#2}{#3} }
 }
%    \end{macrocode}
%
% \subsection{Error/warning/info messages}
%
% Shorthands for messages:
%    \begin{macrocode}
\cs_new:Npn \fontspec_error:n     { \msg_error:nn     {fontspec} }
\cs_new:Npn \fontspec_error:nx    { \msg_error:nnx    {fontspec} }
\cs_new:Npn \fontspec_warning:n   { \msg_warning:nn   {fontspec} }
\cs_new:Npn \fontspec_warning:nx  { \msg_warning:nnx  {fontspec} }
\cs_new:Npn \fontspec_warning:nxx { \msg_warning:nnxx {fontspec} }
\cs_new:Npn \fontspec_info:n      { \msg_info:nn      {fontspec} }
\cs_new:Npn \fontspec_info:nx     { \msg_info:nnx     {fontspec} }
\cs_new:Npn \fontspec_info:nxx    { \msg_info:nnxx    {fontspec} }
\cs_new:Npn \fontspec_trace:n     { \msg_trace:nn     {fontspec} }
%    \end{macrocode}
%
% Errors:
%    \begin{macrocode}
\msg_new:nnn {fontspec} {no-size-info}
{
  Size~ information~ must~ be~ supplied.\\
  For~ example,~ SizeFeatures={Size={8-12},...}.
}
\msg_new:nnnn {fontspec} {rename-feature-not-exist}
{
  The~ feature~ #1~ doesn't~ appear~ to~ be~ defined.
}
{
  It~ looks~ like~ you're~ trying~ to~ rename~ a~ feature~ that~ doesn't~ exist.
}
\msg_new:nnn {fontspec} {no-glyph}
{
  '\l_fontspec_fontname_tl'~ does~ not~ contain~ glyph~ #1.
}
\msg_new:nnnn {fontspec} {unknown-options}
{
  The~ following~ font~ options~ are~ not~ recognised:\\
  \space\space\space\space #1
}
{
  There~ is~ probably~ a~ typo~ in~ the~ font~ feature~ selection.
}
\msg_new:nnnn {fontspec} {euler-too-late}
{
  The~ euler~ package~ must~ be~ loaded~ BEFORE~ fontspec.
}
{
  fontspec~ only~ overwrites~ euler's~ attempt~ to\\
  define~ the~ maths~ text~ fonts~ if~ fontspec~ is\\
  loaded~ after~ euler.~ Type~ <return>~ to~ proceed\\
  with~ incorrect~ \string\mathit,~ \string\mathbf,~ etc.
}
\msg_new:nnnn {fontspec} {no-xcolor}
{
  Cannot~ load~ named~ colours~ without~ the~ xcolor~ package.
}
{
  Sorry,~ I~ can't~ do~ anything~ to~ help.~ Instead~ of~ loading\\
  the~ color~ package,~ use~ xcolor~ instead.~ It's~ better.
}
\msg_new:nnnn {fontspec} {unknown-color-model}
{
  Error~ loading~ colour~ `#1';~ unknown~ colour~ model.
}
{
  Sorry,~ I~ can't~ do~ anything~ to~ help.~ Please~ report~ this~ error\\
  to~ my~ developer~ with~ a~ minimal~ example~ that~ causes~ the~ problem.
}
%    \end{macrocode}
% Warnings:
%    \begin{macrocode}
\msg_new:nnn {fontspec} {addfontfeatures-ignored}
{
  \string\addfontfeature (s)~ ignored;\\
  it~ cannot~ be~ used~ with~ a~ font~ that~ wasn't~ selected~ by~ fontspec.
}
\msg_new:nnn {fontspec} {feature-option-overwrite}
{
  Option~ '#2'~ of~ font~ feature~ '#1'~ overwritten.
}
\msg_new:nnn {fontspec} {script-not-exist-latn}
{
  Font~ '\l_fontspec_fontname_tl'~ does~ not~ contain~ script~ '#1'.\\
  'Latin'~ script~ used~ instead.
}
\msg_new:nnn {fontspec} {script-not-exist}
{
  Font~ '\l_fontspec_fontname_tl'~ does~ not~ contain~ script~ '#1'.
}
\msg_new:nnn {fontspec} {aat-feature-not-exist}
{
  '\XKV@tfam=\XKV@tkey'~ feature~ not~ supported\\
  for~ AAT~ font~ '\l_fontspec_fontname_tl'.
}
\msg_new:nnn {fontspec} {aat-feature-not-exist-in-font}
{
  AAT~ feature~ '\XKV@tfam=\XKV@tkey'~ (#1)~ not~ available\\
  in~ font~ '\l_fontspec_fontname_tl'.
}
\msg_new:nnn {fontspec} {icu-feature-not-exist}
{
  '\XKV@tfam=\XKV@tkey'~ feature~ not~ supported\\
  for~ ICU~ font~ '\l_fontspec_fontname_tl'
}
\msg_new:nnn {fontspec} {icu-feature-not-exist-in-font}
{
  OpenType~ feature~ '\XKV@tfam=\XKV@tkey'~ (#1)~ not~ available\\
  for~ font~ '\l_fontspec_fontname_tl', \\
  with~ script~ '\l_fontspec_script_name_tl',~ and~ language~ '\l_fontspec_lang_name_tl'.
}
\msg_new:nnn {fontspec} {no-opticals}
{
  '\l_fontspec_fontname_tl'~ doesn't~ appear~ to~ have~ an~ Optical~ Size~ axis.
}
\msg_new:nnn {fontspec} {language-not-exist}
{
  Language~ '#1'~ not~ available\\
  for~ font~ '\l_fontspec_fontname_tl'~
  with~ script~ '\l_fontspec_script_name_tl'.\\
  'Default'~ language~ used~ instead.
}
\msg_new:nnn {fontspec} {only-xetex-feature}
{
  Ignored~ XeTeX~ only~ feature:~ '#1'.
}
\msg_new:nnn {fontspec} {only-luatex-feature}
{
  Ignored~ LuaTeX~ only~ feature:~ '#1'.
}
\msg_new:nnn {fontspec} {no-mapping}
{
  Input~ mapping~ not~ (yet?)~ supported~ in~ LuaTeX.
}
\msg_new:nnn {fontspec} {no-mapping-ligtex}
{
  Input~ mapping~ not~ (yet?)~ supported~ in~ LuaTeX.\\
  Use~ "Ligatures=TeX"~ instead~ of~ "Mapping=tex-text".
}
\msg_new:nnn {fontspec} {cm-default-obsolete}
{
  The~ "cm-default"~ package~ option~ is~ obsolete.
}
%    \end{macrocode}
% Info messages:
%    \begin{macrocode}
\msg_new:nnn {fontspec} {defining-font}
{
  Defining~ font~ family~ for~ '#2'~ with~ options~ [\g_fontspec_default_fontopts_tl #1].
}
\msg_new:nnn {fontspec} {defining-raw}
{
  Defining~ shape~
  '\prg_case_str:nnn {#1} {
    {\mddefault/\updefault} {normal}
    {\mddefault/\scdefault} {small~ caps}
    {\bfdefault/\updefault} {bold}
    {\bfdefault/\scdefault} {bold~ small~ caps}
    {\mddefault/\itdefault} {italic}
    {\mddefault/\sidefault} {italic~ small~ caps}
    {\bfdefault/\itdefault} {bold~ italic}
    {\bfdefault/\sidefault} {bold~ italic~ small~ caps}
  } {#1}'~
  with~ NFSS~ specification: \\
  \l_fontspec_nfss_tl
}
\msg_new:nnn {fontspec} {no-font-shape}
{
  Could~ not~ resolve~ font~ #1~ (it~ probably~ doesn't~ exist).
}
\msg_new:nnn {fontspec} {set-scale}
{
  \l_fontspec_fontname_tl\space scale ~=~ \l_fontspec_scale_tl.
}
\msg_new:nnn {fontspec} {setup-math}
{
  Adjusting~ the~ maths~ setup~ (use~ [no-math]~ to~ avoid~ this).
}
\msg_new:nnn {fontspec} {no-scripts}
{
  Font~ \l_fontspec_fontname_tl\space does~ not~ contain~ any~ OpenType~ `Script'~ information.
}
\msg_new:nnn {fontspec} {opa-twice}
{
  Opacity~ set~ twice,~ in~ both~ Colour~ and~ Opacity.\\
  Using~ specification~ "Opacity=#1".
}
\msg_new:nnn {fontspec} {opa-twice-col}
{
  Opacity~ set~ twice,~ in~ both~ Opacity~ and~ Colour.\\
  Using~ an~ opacity~ specification~ in~ hex~ of~ "#1/FF".
}
\msg_new:nnn {fontspec} {bad-colour}
{
  Bad~ colour~ declaration~ "#1".~
  Colour~ must~ be~ one~ of:\\
  *~ a~ named~ xcolor~ colour\\
  *~ a~ six-digit~ hex~ colour~ RRGGBB\\
  *~ an~ eight-digit~ hex~ colour~ RRGGBBTT~ with~ opacity
}
%    \end{macrocode}
%
% \subsection{Option processing}
%
%    \begin{macrocode}
\DeclareOption{cm-default}{
  \fontspec_warning:n {cm-default-obsolete}
}
\DeclareOption{math}{\bool_set_true:N \g_fontspec_math_bool}
\DeclareOption{no-math}{\bool_set_false:N \g_fontspec_math_bool}
\DeclareOption{config}{\bool_set_true:N \g_fontspec_cfg_bool}
\DeclareOption{no-config}{\bool_set_false:N \g_fontspec_cfg_bool}
\DeclareOption{quiet}{
  \msg_redirect_module:nnn { fontspec } { warning } { info }
  \msg_redirect_module:nnn { fontspec } { info } { none }
}
\DeclareOption{silent}{
  \msg_redirect_module:nnn { fontspec } { warning } { none }
  \msg_redirect_module:nnn { fontspec } { info } { none }
}
\ExecuteOptions{config,math}
\ProcessOptions*
%    \end{macrocode}
%
% \subsection{Packages}
% We require the \pkg{calc} package for autoscaling and a recent version of the
% \pkg{xkeyval} package for option processing.
%    \begin{macrocode}
\RequirePackage{calc}
\RequirePackage{xkeyval}[2005/05/07]
%    \end{macrocode}
%
% New for \LuaTeX, we load a new package called `\pkg{fontspec-patches}'
% designed to incorporate the hidden but useful parts of the old \pkg{xltxtra}
% package.
%    \begin{macrocode}
\RequirePackage{fontspec-patches}
%    \end{macrocode}
%
%
% \subsection{Encodings}
% Frank Mittelbach has recommended using the `\texttt{EU}$x$' family of font encodings
% to experiment with Unicode.
% Now that \XeTeX\ can find fonts in the |texmf| tree, the Latin Modern OpenType fonts
% can be used as the defaults. See the |euenc| collection of files for how this is implemented.
%    \begin{macrocode}
\xetex_or_luatex:nnn {\tl_set:Nn \zf@enc} {EU1} {EU2}
\tl_set:Nn \rmdefault {lmr}
\tl_set:Nn \sfdefault {lmss}
\tl_set:Nn \ttdefault {lmtt}
\RequirePackage[\zf@enc]{fontenc}
\tl_set_eq:NN \UTFencname \zf@enc % for xunicode
%    \end{macrocode}
% Dealing with a couple of the problems introduced by \pkg{babel}:
%    \begin{macrocode}
\tl_set_eq:NN \cyrillicencoding \zf@enc
\tl_set_eq:NN \latinencoding    \zf@enc
\g@addto@macro \document {
  \tl_set_eq:NN \cyrillicencoding \zf@enc
  \tl_set_eq:NN \latinencoding    \zf@enc
}
%    \end{macrocode}
% That latin encoding definition is repeated to suppress font warnings.
% Something to do with \cmd\select@language\ ending up in the \texttt{.aux}
% file which is read at the beginning of the document.
%
% \paragraph{xunicode}
% Now we load \pkg{xunicode}, working around its internal \XeTeX\ check
% when under \LuaTeX.
%    \begin{macrocode}
\xetex_or_luatex:nn
{
  \RequirePackage{xunicode}
}
{
  \cs_set_eq:NN \fontspec_tmp: \XeTeXpicfile
  \cs_set:Npn \XeTeXpicfile {}
  \RequirePackage{xunicode}
  \cs_set_eq:NN \XeTeXpicfile \fontspec_tmp:
}
%    \end{macrocode}
%
%
% \subsection{User commands}\label{sec:codeuser}
% This section contains the definitions of the commands detailed in
% the user documentation.  Only the `top level' definitions of the
% commands are contained herein; they all use or define macros which
% are defined or used later on in \vref{sec:codeinternal}.
%
% \subsubsection{Font selection}
% \begin{macro}{\fontspec}
%   This is the main command of the package that
%   selects fonts with various features. It takes two arguments: the
%   \MacOSX\ font name and the optional requested features of that
%   font. It simply runs \cs{zf@fontspec}, which takes the same
%   arguments as the top level macro and puts the new-fangled font
%   family name into the global \cmd{\zf@family}. Then this new font
%   family is selected.
%    \begin{macrocode}
\DeclareDocumentCommand \fontspec { O{} m } {
  \fontencoding {\zf@enc}
  \fontspec_set_family:Nnn \f@family {#1}{#2}
  \selectfont
  \ignorespaces
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\setmainfont}
% \begin{macro}{\setsansfont}
% \begin{macro}{\setmonofont}
%     The following three macros perform equivalent operations setting
%     the default font (using \cs{let} rather than \cs{renewcommand}
%     because \cs{zf@family} will change in the future) for a
%     particular family: `roman', sans serif, or typewriter
%     (monospaced). I end them with |\normalfont| so that if they're
%     used in the document, the change registers immediately.
%    \begin{macrocode}
\DeclareDocumentCommand \setmainfont { O{} m } {
  \fontspec_set_family:Nnn \rmdefault {#1}{#2}
  \normalfont
}
\DeclareDocumentCommand \setsansfont { O{} m } {
  \fontspec_set_family:Nnn \sfdefault {#1}{#2}
  \normalfont
}
\DeclareDocumentCommand \setmonofont { O{} m } {
  \fontspec_set_family:Nnn \ttdefault {#1}{#2}
  \normalfont
}
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
%
%
% \begin{macro}{\setromanfont}
% This is the old name for \cs{setmainfont}, retained
% for backwards compatibility.
%    \begin{macrocode}
\cs_set_eq:NN \setromanfont \setmainfont
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\setmathrm}
% \begin{macro}{\setmathsf}
% \begin{macro}{\setboldmathrm}
% \begin{macro}{\setmathtt}
% These commands are analogous to \cmd\setromanfont\ and others,
% but for selecting the font used for \cmd\mathrm, \etc. They
% can only be used in the preamble of the
% document. \cmd\setboldmathrm\ is used for specifying which
% fonts should be used in \cmd\boldmath.
%    \begin{macrocode}
\DeclareDocumentCommand \setmathrm { O{} m } {
  \fontspec_set_family:Nnn \g_fontspec_mathrm_tl {#1}{#2}
}
\DeclareDocumentCommand \setboldmathrm { O{} m } {
  \fontspec_set_family:Nnn \g_fontspec_bfmathrm_tl {#1}{#2}
}
\DeclareDocumentCommand \setmathsf { O{} m } {
  \fontspec_set_family:Nnn \g_fontspec_mathsf_tl {#1}{#2}
}
\DeclareDocumentCommand \setmathtt { O{} m } {
  \fontspec_set_family:Nnn \g_fontspec_mathtt_tl {#1}{#2}
}
\@onlypreamble\setmathrm
\@onlypreamble\setboldmathrm
\@onlypreamble\setmathsf
\@onlypreamble\setmathtt
%    \end{macrocode}
% If the commands above are not executed, then \cmd\rmdefault\ (\etc)
% will be used.
%    \begin{macrocode}
\def\g_fontspec_mathrm_tl{\rmdefault}
\def\g_fontspec_mathsf_tl{\sfdefault}
\def\g_fontspec_mathtt_tl{\ttdefault}
\tl_clear:N \g_fontspec_bfmathrm_tl
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
% \end{macro}
%
% \begin{macro}{\newfontfamily}
% \begin{macro}{\newfontface}
%   This macro takes the arguments of \cs{fontspec} with a prepended
%   \meta{instance cmd} (code for middle optional argument generated
%   by \name{Scott Pakin}'s \textsf{newcommand.py}). This command is used
%   when a specific font instance needs to be referred to repetitively
%   (\eg, in a section heading) since continuously calling
%   \cs{zf@fontspec} is inefficient because it must parse the
%   option arguments every time.
%
%   \cs{fontspec_select:nn} defines a font family and saves its name in
%   \cs{zf@family}. This family is then used in a typical NFSS \cmd\fontfamily\
%   declaration, saved in the macro name specified.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontfamily { m O{} m } {
  \fontspec_select:nn{#2}{#3}
  \use:x {
    \exp_not:N \DeclareRobustCommand \exp_not:N #1 {
      \exp_not:N \fontencoding {\zf@enc}
      \exp_not:N \fontfamily {\zf@family} \exp_not:N \selectfont
    }
  }
}
%    \end{macrocode}
% \cmd\newfontface\ uses an undocumented feature of the \feat{BoldFont}
% feature; if its argument is empty (\ie, |BoldFont={}|), then no bold
% font is searched for.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontface { m O{} m } {
  \newfontfamily #1 [ BoldFont={},ItalicFont={},SmallCapsFont={},#2 ] {#3}
}
%    \end{macrocode}
% \end{macro} \end{macro}
%
% \subsubsection{Font feature selection}
%
% \begin{macro}{\defaultfontfeatures}
%   This macro takes one argument that consists of all of feature
%   options that will be applied by default to all subsequent
%   \cs{fontspec}, et al., commands. It stores its value in
%   \cs{g_fontspec_default_fontopts_tl} (initialised empty), which is
%   concatenated with the individual macro choices in the
%   [...] macro.
%    \begin{macrocode}
\DeclareDocumentCommand \defaultfontfeatures {m} {
  \tl_set:Nn \g_fontspec_default_fontopts_tl {#1,}
}
\tl_clear:N \g_fontspec_default_fontopts_tl
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\addfontfeatures}
%   In order to be able to extend the feature selection of
%   a given font, two things need to be known: the currently selected
%   features, and the currently selected font. Every time a font
%   family is created, this information is saved inside a control
%   sequence with the name of the font family itself.
%
%   This macro extracts this information, then appends the requested
%   font features to add to the already existing ones, and calls the
%   font again with the top level \cs{fontspec} command.
%
%   The default options are \emph{not} applied (which is why
%   \cs{g_fontspec_default_fontopts_tl} is emptied inside the group; this is allowed
%   as \cmd\zf@family\ is globally defined in \cmd\fontspec_select:nn), so this
%   means that the only added features to the font are strictly those
%   specified by this command.
%
%   \cs{addfontfeature} is defined as an alias, as I found that I
%   often typed this instead when adding only a single font feature.
%    \begin{macrocode}
\DeclareDocumentCommand \addfontfeatures {m} {
  \ifcsname zf@family@fontdef\f@family\endcsname
    \group_begin:
      \tl_clear:N \g_fontspec_default_fontopts_tl
      \use:x {
        \exp_not:N\fontspec_select:nn
          {\csname zf@family@options\f@family\endcsname,#1}
          {\csname zf@family@fontname\f@family\endcsname}
      }
    \group_end:
    \fontfamily\zf@family\selectfont
  \else
    \fontspec_warning:n {addfontfeatures-ignored}
  \fi
  \ignorespaces
}
\cs_set_eq:NN \addfontfeature \addfontfeatures
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Defining new font features}
%
% \begin{macro}{\newfontfeature}
%   \cs{newfontfeature} takes two arguments: the name of the feature
%   tag by which to reference it, and the string that is used to
%   select the font feature.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontfeature {mm} {
  \define@key[zf]{options}{#1}[]{
    \fontspec_update_fontid:n  {+zf-#1}
    \fontspec_update_featstr:n {#2}
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\newAATfeature}
% This command assigns a new AAT feature by its code (|#2|,|#3|) to a new name (|#1|).
% Better than \cmd\newfontfeature\ because it checks if the feature exists in the
% font it's being used for.
%    \begin{macrocode}
\DeclareDocumentCommand \newAATfeature {mmmm} {
  \unless\ifcsname zf@options@#1\endcsname
    \fontspec_define_font_feature:n{#1}
  \fi
  \key@ifundefined[zf]{#1}{#2}{}{
    \fontspec_warning:nxx {feature-option-overwrite}{#1}{#2}
  }
  \fontspec_define_feature_option:nnnnn{#1}{#2}{#3}{#4}{}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newICUfeature}
% \begin{macro}{\newopentypefeature}
% This command assigns a new OpenType feature by its abbreviation (|#2|) to a new name (|#1|).
% Better than \cmd\newfontfeature\ because it checks if the feature exists in the
% font it's being used for.
%    \begin{macrocode}
\DeclareDocumentCommand \newICUfeature {mmm} {
  \unless\ifcsname zf@options@#1\endcsname
    \fontspec_define_font_feature:n{#1}
  \fi
  \key@ifundefined[zf]{#1}{#2}{}{
    \fontspec_warning:nxx {feature-option-overwrite}{#1}{#2}
  }
  \fontspec_define_feature_option:nnnnn{#1}{#2}{}{}{#3}
}
\cs_set_eq:NN \newopentypefeature \newICUfeature
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\aliasfontfeature}
% \begin{macro}{\aliasfontfeatureoption}
% User commands for renaming font features and font feature options.
% Provided I've been consistent, they should work for everything.
%    \begin{macrocode}
\DeclareDocumentCommand \aliasfontfeature {mm} {\multi@alias@key{#1}{#2}}
\DeclareDocumentCommand \aliasfontfeatureoption {mmm} {
  \keyval@alias@key[zf@feat]{#1}{#2}{#3}
}
%    \end{macrocode}
% \end{macro} \end{macro}
%
% \begin{macro}{\newfontscript}
% Mostly used internally, but also possibly useful for users, to define new OpenType
% `scripts', mapping logical names to OpenType script tags.
% Iterates though the scripts in the selected font to check that it's a valid
% feature choice, and then prepends the (\XeTeX) \cmd\font\ feature string with the appropriate
% script selection tag.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontscript {mm}
{
  \fontspec_new_script:nn {#1} {#2}
  \fontspec_new_script:nn {#2} {#2}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \fontspec_new_script:nn #1#2
{
  \define@key[zf@feat]{Script}{#1}[]{
    \fontspec_check_script:nTF {#2} {
      \fontspec_update_fontid:n {+script=#1}
      \tl_set:Nn \l_fontspec_script_tl {#2}
      \int_set:Nn \l_fontspec_script_int {\l_fontspec_strnum_int}
    }{
      \fontspec_check_script:nTF {latn} {
        \fontspec_warning:nx {script-not-exist-latn} {#1}
        \setkeys[zf@feat]{Script}{Latin}
      }{
        \fontspec_warning:nx {script-not-exist} {#1}
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newfontlanguage}
% Mostly used internally, but also possibly useful for users, to define new OpenType
% `languages', mapping logical names to OpenType language tags.
% Iterates though the languages in the selected font to check that it's a valid
% feature choice, and then prepends the (\XeTeX) \cmd\font\ feature string with the appropriate
% language selection tag.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontlanguage {mm}
{
  \fontspec_new_lang:nn {#1} {#2}
  \fontspec_new_lang:nn {#2} {#2}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \fontspec_new_lang:nn #1#2
{
  \define@key[zf@feat]{Lang}{#1}[]{
    \fontspec_check_lang:nTF {#2} {
      \fontspec_update_fontid:n {+lang=#1}
      \tl_set:Nn \l_fontspec_lang_tl {#2}
      \int_set:Nn \l_fontspec_language_int {\l_fontspec_strnum_int}
    }{
      \fontspec_warning:nx {language-not-exist} {#1}
      \setkeys[zf@feat]{Lang}{Default}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareFontsExtensions}
% \texttt{dfont} would never be uppercase, right?
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontsExtensions {m}
{
  \tl_set:Nx \l_fontspec_extensions_clist { \zap@space #1~\@empty }
}
\DeclareFontsExtensions{.otf,.ttf,.OTF,.TTF,.ttc,.TTC,.dfont}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Programmer's interface}
%
% These functions are not used directly by fontspec when defining fonts;
% they are designed to be used by other packages who wish to do font-related
% things on top of fontspec itself.
%
% Because I haven't fully explored how these functions will behave in
% practise, I am not giving them user-level names. As it becomes more clear
% which of these should be accessible by document writers, I'll open them up
% a little more.
%
% All functions are defined assuming that the font to be queried is
% currently selected as a fontspec font. (I.e., via \verb|\fontspec| or
% from a \verb|\newfontfamily| macro or from \verb|\setmainfont| and so on.)
%
% \begin{macro}{\fontspec_if_fontspec_font:TF}
% Test whether the currently selected font has been loaded by fontspec.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_fontspec_font: {TF,T,F} {
  \ifcsname zf@family@fontdef\f@family\endcsname
    \prg_return_true:
  \else
    \prg_return_false:
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_aat_feature:nnTF}
% Conditional to test if the currently selected font contains the \AAT\
% feature (|#1|,|#2|).
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_aat_feature:nn {TF,T,F} {
  \fontspec_if_fontspec_font:TF {
    \font_set:Nnn \zf@basefont {\use:c{zf@family@fontdef\f@family}} {\f@size pt}
    \bool_if:NTF \l_fontspec_atsui_bool {
      \fontspec_make_AAT_feature_string:nnTF {#1}{#2}
        \prg_return_true: \prg_return_false:
    }{
      \prg_return_false:
    }
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_opentype:TF}
% Test whether the currently selected font is an OpenType font.
% Always true for LuaTeX fonts.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_opentype: {TF,T,F} {
  \fontspec_if_fontspec_font:TF {
    \font_set:Nnn \zf@basefont {\csname zf@family@fontdef\f@family\endcsname} {\f@size pt}
    \fontspec_set_font_type:
    \bool_if:NTF \l_fontspec_icu_bool \prg_return_true: \prg_return_false:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nTF}
% Test whether the currently selected font contains the raw OpenType
% feature |#1|. E.g.: |\fontspec_if_feature:nTF {pnum} {True} {False}|
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_feature:n {TF,T,F} {
  \fontspec_if_fontspec_font:TF {
    \font_set:Nnn \zf@basefont {\csname zf@family@fontdef\f@family\endcsname} {\f@size pt}
    \fontspec_set_font_type:
    \bool_if:NTF \l_fontspec_icu_bool {
      \int_set:Nv \l_fontspec_script_int {g_fontspec_script_num_(\f@family)_tl}
      \int_set:Nv \l_fontspec_language_int {g_fontspec_lang_num_(\f@family)_tl}
      \tl_set:Nv \l_fontspec_script_tl {g_fontspec_script_(\f@family)_tl}
      \tl_set:Nv \l_fontspec_lang_tl   {g_fontspec_lang_(\f@family)_tl}
      \fontspec_check_ot_feat:nTF {#1} {\prg_return_true:} {\prg_return_false:}
    }{
      \prg_return_false:
    }
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nnnTF}
% Test whether the currently selected font with raw OpenType script tag |#1| and raw OpenType language tag |#2| contains the raw OpenType feature tag |#3|. E.g.: |\fontspec_if_feature:nTF {latn} {ROM} {pnum} {True} {False}|
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_feature:nnn {TF,T,F} {
  \fontspec_if_fontspec_font:TF {
    \font_set:Nnn \zf@basefont {\csname zf@family@fontdef\f@family\endcsname} {\f@size pt}
    \fontspec_set_font_type:
    \bool_if:NTF \l_fontspec_icu_bool {
      \fontspec_iv_str_to_num:Nn \l_fontspec_script_int {#1}
      \fontspec_iv_str_to_num:Nn \l_fontspec_language_int {#2}
      \fontspec_check_ot_feat:nTF {#3} \prg_return_true: \prg_return_false:
    }{
      \prg_return_false:
    }
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_script:nTF}
% Test whether the currently selected font contains the raw OpenType
% script |#1|. E.g.: |\fontspec_if_script:nTF {latn} {True} {False}|
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_script:n {TF,T,F} {
  \fontspec_if_fontspec_font:TF {
    \font_set:Nnn \zf@basefont {\csname zf@family@fontdef\f@family\endcsname} {\f@size pt}
    \fontspec_set_font_type:
    \bool_if:NTF \l_fontspec_icu_bool {
      \fontspec_check_script:nTF {#1} \prg_return_true: \prg_return_false:
    }{
      \prg_return_false:
    }
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#1|. E.g.: |\fontspec_if_language:nTF {ROM} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_language:n {TF,T,F} {
  \fontspec_if_fontspec_font:TF {
    \font_set:Nnn \zf@basefont {\csname zf@family@fontdef\f@family\endcsname} {\f@size pt}
    \fontspec_set_font_type:
    \bool_if:NTF \l_fontspec_icu_bool {
      \tl_set:Nv \l_fontspec_script_tl {g_fontspec_script_(\f@family)_tl}
      \int_set:Nv \l_fontspec_script_int {g_fontspec_script_num_(\f@family)_tl}
      \fontspec_check_lang:nTF {#1} \prg_return_true: \prg_return_false:
    }{
      \prg_return_false:
    }
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nnTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#2| in script |#1|. E.g.: |\fontspec_if_language:nnTF {cyrl} {SRB} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_language:nn {TF,T,F} {
  \fontspec_if_fontspec_font:TF {
    \font_set:Nnn \zf@basefont {\csname zf@family@fontdef\f@family\endcsname} {\f@size pt}
    \fontspec_set_font_type:
    \bool_if:NTF \l_fontspec_icu_bool {
      \tl_set:Nn \l_fontspec_script_tl {#1}
      \fontspec_iv_str_to_num:Nn \l_fontspec_script_int {#1}
      \fontspec_check_lang:nTF {#2} \prg_return_true: \prg_return_false:
    }{
      \prg_return_false:
    }
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_current_script:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType script tag |#1|.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_current_script:n {TF,T,F} {
  \fontspec_if_fontspec_font:TF {
    \font_set:Nnn \zf@basefont {\csname zf@family@fontdef\f@family\endcsname} {\f@size pt}
    \fontspec_set_font_type:
    \bool_if:NTF \l_fontspec_icu_bool {
      \str_if_eq:nvTF {#1} {g_fontspec_script_(\f@family)_tl}
        {\prg_return_true:} {\prg_return_false:}
    }{
      \prg_return_false:
    }
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_current_language:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType language tag |#1|.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_current_language:n {TF,T,F} {
  \fontspec_if_fontspec_font:TF {
    \font_set:Nnn \zf@basefont {\csname zf@family@fontdef\f@family\endcsname} {\f@size pt}
    \fontspec_set_font_type:
    \bool_if:NTF \l_fontspec_icu_bool {
      \str_if_eq:nvTF {#1} {g_fontspec_lang_(\f@family)_tl}
        {\prg_return_true:} {\prg_return_false:}
    }{
      \prg_return_false:
    }
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_set_family:Nnn}
% \darg{family}
% \darg{fontspec features}
% \darg{font name}
% Defines a new font family from given \meta{features} and \meta{font},
% and stores the name in the variable \meta{family}.
% See the standard \pkg{fontspec} user commands for applications of this
% function.
%
% We want to store the actual name of the font family within the \meta{family}
% variable because the actual \LaTeX\ family name is automatically generated
% by fontspec and it's easier to keep it that way.
%
% Please use |\fontspec_set_family:Nnn| instead of |\fontspec_select:nn|,
% which may change in the future.
%    \begin{macrocode}
\cs_new:Npn \fontspec_set_family:Nnn #1#2#3 {
  \fontspec_select:nn {#2}{#3}
  \tl_set_eq:NN #1 \zf@family
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{expl3 interface for font loading}
%
% Using |\font\1={xyz}| notation doesn't work at present with LuaLaTeX,
% although it should be the correct way to do things. Continue to use
% |\font\1="xyz"| for now for both engines.
%    \begin{macrocode}
\xetex_or_luatex:nnn { \cs_set:Npn \fontspec_fontwrap:n #1 } { "#1" } { {#1} }
\cs_set:Npn \fontspec_fontwrap:n #1 { "#1" }
%    \end{macrocode}
%
% Beginnings of an `l3font', I guess:
%    \begin{macrocode}
\cs_set_eq:NN \font_set_eq:NN \tex_let:D
\cs_new:Npn \font_set:Nnn #1#2#3 {
  \font #1 = \fontspec_fontwrap:n {#2} ~at~#3\scan_stop:
}
\cs_new:Npn \font_gset:Nnn #1#2#3 {
  \global \font #1 = \fontspec_fontwrap:n {#2} ~at~#3\scan_stop:
}
%    \end{macrocode}
%
% \begin{macro}{\font_glyph_if_exist:NnTF}
%    \begin{macrocode}
\prg_new_conditional:Nnn \font_glyph_if_exist:Nn {p,TF,T,F} {
  \etex_iffontchar:D #1 #2 \scan_stop:
    \prg_return_true:
  \else:
    \prg_return_false:
  \fi:
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Internal macros}
% \label{sec:codeinternal}
%
% The macros from here in are used internally by all those defined above.
% They are not designed to remain consistent between versions.
%
%
%
%
% \begin{macro}{\fontspec_select:nn}
% This is the command that defines font families for use, the underlying
% procedure of all \cmd\fontspec-like commands. Given a
% list of font features (|#1|) for a requested font (|#2|),
% it will define an NFSS
% family for that font and put the family name (globally) into \cs{zf@family}.
% The \TeX\ `\cs{font}' command is (globally) stored in \cs{zf@basefont}.
%
% This macro does its processing inside a group to attempt to restrict the scope of its internal processing. This works to some degree to insulate the internal commands from having to be manually cleared.
%    \begin{macrocode}
\cs_set:Npn \fontspec_select:nn #1#2 {
  \group_begin:
  \fontspec_init:
%    \end{macrocode}
% \cmd{\l_fontspec_fontname_tl} is used as the generic name of the font being defined.
% \cmd{\l_fontspec_fontid_tl} is the unique identifier of the font with all its
% features.
% \cmd{\l_fontspec_fontname_up_tl} is the font specifically to be used as the upright font.
%    \begin{macrocode}
  \tl_set:Nx \l_fontspec_fontname_tl {#2}
  \luatex_if_engine:T {
    \tl_replace_all_in:Nnn \l_fontspec_fontname_tl {~} {}
  }
  \tl_set_eq:NN \l_fontspec_fontid_tl \l_fontspec_fontname_tl
  \tl_set_eq:NN \l_fontspec_fontname_up_tl \l_fontspec_fontname_tl
%    \end{macrocode}
% Now convert the requested features to font definition
% strings. First the features are parsed for information about font
% loading (whether it's a named font or external font, etc.), and then
% information is extracted for the names of the other shape fonts.
%
% Then the mapping from user features to low-level features occurs.
% This is performed with \cs{fontspec_get_features:n}, in
% which \cs{setkeys} retrieves the requested font features and
% processes them. As \cs{setkeys} is run multiple times, some of its
% information storing only occurs once while we decide if the font family
% has been defined or not. When the later processing is occuring per-shape
% this no longer needs to happen; this is indicated by the `firsttime'
% conditional.
%    \begin{macrocode}
  \fontspec_preparse_features:nn {#1}{#2}
  \fontspec_set_scriptlang:
  \fontspec_get_features:n {}
  \bool_set_false:N \l_fontspec_firsttime_bool
%    \end{macrocode}
% Check if the family is unique and, if so, save its information.
% (\cs{addfontfeature} and other macros use this data.)
% Then the font family and its shapes are defined in the NFSS.
%
% All NFSS specifications take their default values, so if any of them
% are redefined, the shapes will be selected to fit in with the
% current state. For example, if \cmd\bfdefault\ is redefined to |b|, all
% bold shapes defined by this package will also be assigned to |b|.
%    \begin{macrocode}
  \fontspec_save_family:nT {#2} {
    \fontspec_info:nxx {defining-font} {#1} {#2}
    \fontspec_save_fontinfo:nn {#1} {#2}
    \DeclareFontFamily{\zf@enc}{\zf@family}{}
    \fontspec_set_upright:
    \fontspec_set_bold:
    \fontspec_set_italic:
    \fontspec_set_slanted:
    \fontspec_set_bold_italic:
    \fontspec_set_bold_slanted:
  }
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\zf@fontspec}
% For backwards compatibility. Do not use this from now on!
%    \begin{macrocode}
\cs_set_eq:NN \zf@fontspec \fontspec_select:nn
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_preparse_features:nn}
% Perform the (multi-step) feature parsing process.
%    \begin{macrocode}
\cs_new:Npn \fontspec_preparse_features:nn #1#2 {
%    \end{macrocode}
% Detect if external fonts are to be used, possibly automatically, and
% parse fontspec features for bold/italic fonts and their features.
%    \begin{macrocode}
  \fontspec_if_detect_external:nT {#2}
   { \setkeys[zf]{preparse-external}{ExternalLocation} }
  \fontspec_setkeys:xx {preparse-external} {\g_fontspec_default_fontopts_tl #1}
%    \end{macrocode}
% When \cmd{\l_fontspec_fontname_tl} is augmented with a prefix or whatever to create
% the name of the upright font (\cmd{\l_fontspec_fontname_up_tl}), this latter is the new `general
% font name' to use.
%    \begin{macrocode}
  \tl_set_eq:NN \l_fontspec_fontname_tl \l_fontspec_fontname_up_tl
  \fontspec_setkeys:xx {preparse} {\XKV@rm}
  \clist_set_eq:NN \l_fontspec_fontfeat_clist \XKV@rm
%    \end{macrocode}
% Finally save the `confirmed' font definition.
%    \begin{macrocode}
  \font_set:Nnn \zf@basefont {\fontspec_fullname:n {\l_fontspec_fontname_up_tl}} {\f@size pt}
  \fontspec_set_font_type:
  \font_gset:Nnn \zf@basefont {\fontspec_fullname:n {\l_fontspec_fontname_up_tl}} {\f@size pt}
  \zf@basefont % this is necessary for LuaLaTeX to check the scripts properly
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_detect_external:nT}
% Check if either the fontname ends with a known font extension.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_detect_external:n {T}
 {
  \clist_map_inline:Nn \l_fontspec_extensions_clist
   {
    \bool_set_false:N \l_tmpa_bool
    \tl_if_in:nnT {#1 <= end_of_string} {##1 <= end_of_string}
      { \bool_set_true:N \l_tmpa_bool \clist_map_break: }
   }
  \bool_if:NTF \l_tmpa_bool \prg_return_true: \prg_return_false:
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_fullname:n}
% Constructs the complete font name based on a common piece of info.
%    \begin{macrocode}
\cs_set:Npn \fontspec_fullname:n #1 {
  \fontspec_namewrap:n { #1 \l_fontspec_extension_tl }
  \l_fontspec_renderer_tl
  \l_fontspec_optical_size_tl
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fontspec_save_family:nT}
%% Now we have a unique (in fact, too unique!) string that contains
% the family name and every option in abbreviated form. This is used
% with a counter to create a simple NFSS family name for the font we're
% selecting.
%
% The font name is fully expanded, in case it's defined in terms of macros, before having its spaces zapped.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_save_family:n {T} {
  \cs_if_exist:cF {g_fontspec_UID_\l_fontspec_fontid_tl}
  {
    \cs_if_exist:cTF {g_fontspec_family_#1_int} {
      \int_gincr:c {g_fontspec_family_#1_int}
    }{
      \int_new:c {g_fontspec_family_#1_int}
    }
    \edef\@tempa{#1~}
    \tl_gset:cx {g_fontspec_UID_\l_fontspec_fontid_tl} {
      \expandafter\zap@space\@tempa\@empty
          ( \int_use:c {g_fontspec_family_#1_int} )
    }
  }
  \tl_gset:Nv \zf@family {g_fontspec_UID_\l_fontspec_fontid_tl}
  \cs_if_exist:cTF {zf@family@fontname\zf@family}
    \prg_return_false: \prg_return_true:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_set_scriptlang:}
% Only necessary for OpenType fonts.
% First check if the font supports scripts, then apply defaults if
% none are explicitly requested. Similarly with the language settings.
%    \begin{macrocode}
\cs_new:Npn \fontspec_set_scriptlang: {
  \bool_if:NT \l_fontspec_firsttime_bool {
    \tl_if_empty:NTF \l_fontspec_script_name_tl {
      \fontspec_check_script:nTF {latn}
      {
        \tl_set:Nn \l_fontspec_script_name_tl {Latin}
        \tl_if_empty:NT \l_fontspec_lang_name_tl {
          \tl_set:Nn \l_fontspec_lang_name_tl {Default}
        }
        \fontspec_setkeys:xxx {feat} {Script} {\l_fontspec_script_name_tl}
        \fontspec_setkeys:xxx {feat} {Lang}   {\l_fontspec_lang_name_tl}
      }
      {
        \fontspec_info:n {no-scripts}
      }
    }
    {
      \tl_if_empty:NT \l_fontspec_lang_name_tl {
        \tl_set:Nn \l_fontspec_lang_name_tl {Default}
      }
      \fontspec_setkeys:xxx {feat} {Script} {\l_fontspec_script_name_tl}
      \fontspec_setkeys:xxx {feat} {Lang}   {\l_fontspec_lang_name_tl}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_save_fontinfo:nn}
% Saves the relevant font information for future processing.
%    \begin{macrocode}
\cs_new:Npn \fontspec_save_fontinfo:nn #1#2 {
    \tl_gset:cx {zf@family@fontname\zf@family} {#2}
    \tl_gset:cx {zf@family@options\zf@family} {\g_fontspec_default_fontopts_tl #1}
    \tl_gset:cx {zf@family@fontdef\zf@family} {
      \fontspec_fullname:n {\l_fontspec_fontname_tl} :
        \l_fontspec_pre_feat_sclist \l_fontspec_rawfeatures_sclist
    }
    \tl_gset:cV {g_fontspec_script_num_(\zf@family)_tl} \l_fontspec_script_int
    \tl_gset:cV {g_fontspec_lang_num_(\zf@family)_tl} \l_fontspec_language_int
    \tl_gset_eq:cN {g_fontspec_script_(\zf@family)_tl} \l_fontspec_script_tl
    \tl_gset_eq:cN {g_fontspec_lang_(\zf@family)_tl}   \l_fontspec_lang_tl
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_set_upright:}
% Sets the upright shape.
%    \begin{macrocode}
\cs_new:Npn \fontspec_set_upright: {
  \fontspec_make_font_shapes:nnnn \l_fontspec_fontname_tl
    \mddefault \updefault \l_fontspec_fontfeat_up_clist
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_set_bold:}
% The macros [...], et al., are used to store the name of the
% custom bold, et al., font, if requested as user options. If they are
% empty, the default fonts are used.
%
% The extra bold options defined with
% \feat{BoldFeatures} are appended to the generic font features.
% Then, the bold font is defined either as the ATS
% default ([...] optional argument is to check if
% there actually is one; if not, the bold NFSS series is left
% undefined) or with the font specified with the \feat{BoldFont} feature.
%    \begin{macrocode}
\cs_new:Npn \fontspec_set_bold: {
  \bool_if:NF \l_fontspec_nobf_bool {
    \tl_if_empty:NTF \l_fontspec_fontname_bf_tl {
      \fontspec_make_font_shapes:nnnnn \l_fontspec_fontname_tl {/B}
        \bfdefault \updefault \l_fontspec_fontfeat_bf_clist
    }{
      \fontspec_make_font_shapes:nnnn \l_fontspec_fontname_bf_tl
        \bfdefault \updefault \l_fontspec_fontfeat_bf_clist
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_set_italic:}
% And italic in the same way:
%    \begin{macrocode}
\cs_new:Npn \fontspec_set_italic: {
  \bool_if:NF \l_fontspec_noit_bool {
    \tl_if_empty:NTF \l_fontspec_fontname_it_tl
    { \fontspec_make_font_shapes:nnnnn \l_fontspec_fontname_tl {/I} }
    { \fontspec_make_font_shapes:nnnn  \l_fontspec_fontname_it_tl    }
        \mddefault \itdefault \l_fontspec_fontfeat_it_clist
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_set_slanted:}
% And slanted but only if requested:
%    \begin{macrocode}
\cs_new:Npn \fontspec_set_slanted: {
  \tl_if_empty:NF \l_fontspec_fontname_sl_tl {
    \fontspec_make_font_shapes:nnnn
      \l_fontspec_fontname_sl_tl \mddefault \sldefault \l_fontspec_fontfeat_sl_clist
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_set_bold_italic:}
% % If requested, the custom fonts take precedence when choosing the
% bold italic font. When both italic and bold fonts are requested and
% the bold italic font hasn't been explicitly specified (a rare
% occurance, presumably), the new bold font is used to define the new
% bold italic font.
%    \begin{macrocode}
\cs_new:Npn \fontspec_set_bold_italic: {
  \bool_if:nF {\l_fontspec_nobf_bool || \l_fontspec_nobf_bool} {
    \tl_if_empty:NTF \l_fontspec_fontname_bfit_tl
    {
      \tl_if_empty:NTF \l_fontspec_fontname_bf_tl
      {
        \tl_if_empty:NTF \l_fontspec_fontname_it_tl
        {
          \fontspec_make_font_shapes:nnnnn \l_fontspec_fontname_tl    {/BI}
        }
        {
          \fontspec_make_font_shapes:nnnnn \l_fontspec_fontname_it_tl {/B}
        }
      }
      {
        \fontspec_make_font_shapes:nnnnn \l_fontspec_fontname_bf_tl {/I}
      }
    }
    {
      \fontspec_make_font_shapes:nnnn  \l_fontspec_fontname_bfit_tl
    }
    \bfdefault \itdefault \l_fontspec_fontfeat_bfit_clist
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_set_bold_slanted:}
% And bold slanted, again, only if requested:
%    \begin{macrocode}
\cs_new:Npn \fontspec_set_bold_slanted: {
  \tl_if_empty:NTF \l_fontspec_fontname_bfsl_tl {
    \tl_if_empty:NF \l_fontspec_fontname_sl_tl {
      \fontspec_make_font_shapes:nnnnn \l_fontspec_fontname_sl_tl {/B}
         \bfdefault \sldefault \l_fontspec_fontfeat_bfsl_clist
    }
  }{
    \fontspec_make_font_shapes:nnnn \l_fontspec_fontname_bfsl_tl
      \bfdefault \sldefault \l_fontspec_fontfeat_bfsl_clist
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsubsection{Fonts}
%
% \begin{macro}{\fontspec_set_font_type:}
% Now check if the font is to be rendered with \ATSUI\ or \ICU. This will either
% be automatic (based on the font type), or specified by the user via a font feature.
%
% This macro sets booleans
% accordingly depending if the font in \cmd\zf@basefont\ is an \AAT\
% font or an OpenType font or a font with feature axes (either \AAT\ or
% Multiple Master), respectively.
%    \begin{macrocode}
\xetex_or_luatex:nnn { \cs_new:Npn \fontspec_set_font_type: }
   {
    \bool_set_false:N \l_fontspec_tfm_bool
    \bool_set_false:N \l_fontspec_atsui_bool
    \bool_set_false:N \l_fontspec_icu_bool
    \bool_set_false:N \l_fontspec_mm_bool
    \bool_set_false:N \l_fontspec_graphite_bool
    \ifcase\XeTeXfonttype\zf@basefont
      \bool_set_true:N \l_fontspec_tfm_bool
    \or
      \bool_set_true:N \l_fontspec_atsui_bool
      \ifnum\XeTeXcountvariations\zf@basefont > \c_zero
        \bool_set_true:N \l_fontspec_mm_bool
      \fi
    \or
      \bool_set_true:N \l_fontspec_icu_bool
    \fi
%    \end{macrocode}
% If automatic, the \cmd{\l_fontspec_renderer_tl} token list will still be
% empty (other suffices that could be added will be later in the feature
% processing), and if it is indeed still empty, assign it a value so that the
% other weights of the font are specifically loaded with the same renderer.
%    \begin{macrocode}
    \tl_if_empty:NT \l_fontspec_renderer_tl {
      \bool_if:NTF \l_fontspec_atsui_bool {
        \tl_set:Nn \l_fontspec_renderer_tl {/AAT}
      }{
        \bool_if:NT \l_fontspec_icu_bool {
          \tl_set:Nn \l_fontspec_renderer_tl {/ICU}
        }
      }
    }
  }
  {
    \bool_set_true:N \l_fontspec_icu_bool
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fontspec_make_font_shapes:nnnn,\fontspec_make_font_shapes:nnnnn}
%  \darg{Font name prefix (in the 5-arg case)}
%  \darg{Font name}
%  \darg{Font series}
%  \darg{Font shape}
%  \darg{Font features}
%   This macro eventually uses \cs{DeclareFontShape} to define the font shape in
%   question.
%
%   The optional first
%   argument is used when making the font shapes for bold, italic, and
%   bold italic fonts using \XeTeX's auto-recognition with |#2| as |/B|, |/I|,
%   and |/BI| font name suffixes. If no such font is found, it falls
%   back to the original font name, in which case this macro doesn't
%   proceed and the font shape is not created for the NFSS.
%
% Next, the small caps are defined. [...] is used to
% define the appropriate string for activating small caps in the font,
% if they exist. If we are defining small caps for the upright shape,
% then the small caps shape default is used. For an \emph{italic}
% font, however, the shape parameter is overloaded and we must call
% italic small caps by their own identifier. See \vref{sec:sishape}
% for the code that enables this usage.
%    \begin{macrocode}
\cs_new:Nn \fontspec_make_font_shapes:nnnnn {
  \font_set:Nnn \l_tmpa_font {\fontspec_fullname:n {#1}}   {\f@size pt}
  \font_set:Nnn \l_tmpb_font {\fontspec_fullname:n {#1#2}} {\f@size pt}
  \str_if_eq:xxTF { \fontname \l_tmpa_font } { \fontname \l_tmpb_font }
  { \fontspec_info:nx {no-font-shape} {#1#2} }
  {
    \fontspec_make_font_shapes:nnnn {#1#2}{#3}{#4}{#5}
  }
}
\cs_new:Nn \fontspec_make_font_shapes:nnnn {
  \group_begin:
    \tl_set:Nx \l_fontspec_fontname_tl {#1}
    \font_set:Nnn \zf@basefont {\fontspec_fullname:n {#1}} {\f@size pt}
    \fontspec_declare_shape:nnnn {}{#2}{#3}{#4}
    \tl_if_empty:NTF \l_fontspec_fontname_sc_tl {
      \bool_if:NF \l_fontspec_nosc_bool {
        \fontspec_make_smallcaps:T {
          \fontspec_declare_shape:nnnn {\l_fontspec_sc_featstr_sclist} {#2}
            { \tl_if_eq:NNTF #3 \itdefault \sidefault \scdefault }
            { #4 \l_fontspec_fontfeat_sc_clist }
        }
      }
    }{
      \tl_set:Nx \l_fontspec_fontname_tl {\l_fontspec_fontname_sc_tl}
      \fontspec_declare_shape:nnnn {}{#2}
        { \tl_if_eq:NNTF #3 \itdefault \sidefault \scdefault }
        { #4 \l_fontspec_fontfeat_sc_clist }
    }
  \group_end:
}
%    \end{macrocode}
% Note that the test for italics to choose the \cmd\sidefault\ shape
% only works while \cmd\fontspec_select:nn\ passes single tokens to this macro\dots
% \end{macro}
%
% \begin{macro}{\fontspec_declare_shape:nnnn}
% \darg{Raw appended font features}
% \darg{Font series}
% \darg{Font shape}
% \darg{Font features}
% Wrapper for \cmd\DeclareFontShape.
%    \begin{macrocode}
\cs_new:Npn \fontspec_declare_shape:nnnn #1#2#3#4 {
  \clist_if_empty:NTF \l_fontspec_sizefeat_clist
  {
    \fontspec_get_features:n {#4}
    \tl_set:Nx \l_fontspec_nfss_tl {
      <-> \l_fontspec_scale_tl
      \fontspec_fontwrap:n {
        \fontspec_fullname:n {\l_fontspec_fontname_tl} :
          \l_fontspec_pre_feat_sclist \l_fontspec_rawfeatures_sclist #1
      }
    }
  }
%    \end{macrocode}
% Default code, above, sets things up for no optical size fonts or features.
% On the other hand, loop through \feat{SizeFeatures} arguments, which
% are of the form
% {\par\centering |SizeFeatures={{<one>},{<two>},{<three>}}|.\par}
%    \begin{macrocode}
  {
    \tl_clear:N \l_fontspec_nfss_tl
    \clist_map_inline:Nn \l_fontspec_sizefeat_clist {

      \tl_clear:N \l_fontspec_size_tl
      \tl_set_eq:NN \l_fontspec_sizedfont_tl \l_fontspec_fontname_tl

      \fontspec_setkeys:xx {sizing} { \expandafter \use:n ##1 }
      \tl_if_empty:NT \l_fontspec_size_tl { \fontspec_error:n {no-size-info} }
      \fontspec_get_features:n{ #4 , \XKV@rm }

      \tl_put_right:Nx \l_fontspec_nfss_tl {
        <\l_fontspec_size_tl> \l_fontspec_scale_tl
        \fontspec_fontwrap:n {
          \fontspec_fullname:n { \l_fontspec_sizedfont_tl }
          : \l_fontspec_pre_feat_sclist \l_fontspec_rawfeatures_sclist #1
        }
      }

    }
  }
%    \end{macrocode}
% And finally the actual font shape declaration using \cmd\l_fontspec_nfss_tl\ defined above.
% \cmd\l_fontspec_postadjust_tl\ is defined in various places to deal with things like the hyphenation
% character and interword spacing.
%    \begin{macrocode}
  \fontspec_info:nx {defining-raw} {#2/#3}
  \use:x{
    \exp_not:N\DeclareFontShape{\zf@enc}{\zf@family}{#2}{#3}
      {\l_fontspec_nfss_tl}{\l_fontspec_postadjust_tl}
  }
%    \end{macrocode}
% This extra stuff for the slanted shape substitution is a little bit awkward,
% but I'd rather have it here than break out yet another macro. Alternatively,
% one day I might just redefine \cmd\slshape. Why not, eh?
%    \begin{macrocode}
  \str_if_eq:xxT {#3} {\itdefault}
  {
    \use:x {
      \exp_not:N \DeclareFontShape {\zf@enc}{\zf@family}{#2}{\sldefault}
        {<->ssub*\zf@family/#2/\itdefault}{\l_fontspec_postadjust_tl}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_fontspec_pre_feat_sclist}
% These are the features always applied to a font selection before other
% features.
%    \begin{macrocode}
\xetex_or_luatex:nnn { \tl_set:Nn \l_fontspec_pre_feat_sclist }
  {
    \bool_if:NT \l_fontspec_icu_bool {
      \tl_if_empty:NF \l_fontspec_script_tl
      {
        script   = \l_fontspec_script_tl ;
        language = \l_fontspec_lang_tl   ;
      }
    }
  }
  {
    mode     = \l_fontspec_mode_tl   ;
    \tl_if_empty:NF \l_fontspec_script_tl
    {
      script   = \l_fontspec_script_tl ;
      language = \l_fontspec_lang_tl   ;
    }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fontspec_update_fontid:n}
% This macro is used to build up a complex family name based on its
% features.
%
% The \meta{firsttime} boolean is set true in \cmd{\fontspec_select:nn} only the first
% time \cmd{zf@get@feature@requests} is called, so that the family
% name is only created once.
%    \begin{macrocode}
\cs_new:Nn \fontspec_update_fontid:n {
  \bool_if:NT \l_fontspec_firsttime_bool {
    \tl_gput_right:Nx \l_fontspec_fontid_tl {#1}
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Features}
%
% \begin{macro}{\fontspec_get_features:n}
%   This macro is a wrapper for |\setkeys| which expands and adds a
%   default specification to the original passed options. It begins by
%   initialising the commands used to hold font-feature specific
%   strings.
%   Its argument is any additional features to prepend to the default.
%    \begin{macrocode}
\cs_set:Npn \fontspec_get_features:n #1 {
  \sclist_clear:N \l_fontspec_rawfeatures_sclist
  \tl_clear:N \l_fontspec_scale_tl
  \tl_set_eq:NN \l_fontspec_opacity_tl \g_fontspec_opacity_tl
  \tl_set_eq:NN \l_fontspec_hexcol_tl \g_fontspec_hexcol_tl
  \tl_clear:N \l_fontspec_postadjust_tl
  \fontspec_setkeys:xx {options} {\l_fontspec_fontfeat_clist #1}
  \bool_if:NT \l_fontspec_firsttime_bool {
    \tl_if_empty:NF \XKV@rm {
      \fontspec_error:nx {unknown-options} { \exp_not:V \XKV@rm }
    }
  }
%    \end{macrocode}
% Finish the colour specification.
% Do not set the colour if not explicitly spec'd else \verb|\color| (using
% specials) will not work.
%    \begin{macrocode}
  \str_if_eq:xxF { \l_fontspec_hexcol_tl \l_fontspec_opacity_tl }
                { \g_fontspec_hexcol_tl \g_fontspec_opacity_tl }
  {
    \fontspec_update_featstr:n{color=\l_fontspec_hexcol_tl\l_fontspec_opacity_tl}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_init:}
% Initialisations that either need to occur globally:
% (all setting of these variables is done locally inside a group)
%    \begin{macrocode}
\tl_clear:N \l_fontspec_fontname_bf_tl
\tl_clear:N \l_fontspec_fontname_it_tl
\tl_clear:N \l_fontspec_fake_slant_tl
\tl_clear:N \l_fontspec_fake_embolden_tl
\tl_clear:N \l_fontspec_fontname_bfit_tl
\tl_clear:N \l_fontspec_fontname_sl_tl
\tl_clear:N \l_fontspec_fontname_bfsl_tl
\tl_clear:N \l_fontspec_fontname_sc_tl
\tl_clear:N \l_fontspec_fontfeat_up_clist
\tl_clear:N \l_fontspec_fontfeat_bf_clist
\tl_clear:N \l_fontspec_fontfeat_it_clist
\tl_clear:N \l_fontspec_fontfeat_bfit_clist
\tl_clear:N \l_fontspec_fontfeat_sl_clist
\tl_clear:N \l_fontspec_fontfeat_bfsl_clist
\tl_clear:N \l_fontspec_fontfeat_sc_clist
\tl_clear:N \l_fontspec_script_name_tl
\tl_clear:N \l_fontspec_script_tl
\tl_clear:N \l_fontspec_lang_name_tl
\tl_clear:N \l_fontspec_lang_tl
\clist_clear:N \l_fontspec_sizefeat_clist
\tl_new:Nn \g_fontspec_hexcol_tl {000000}
\tl_new:Nn \g_fontspec_opacity_tl {FF~}
%    \end{macrocode}
% Or once per fontspec font invocation:
% (Some of these may be redundant.
% Check whether they're assigned to globally or not.)
%    \begin{macrocode}
\newcommand*\fontspec_init:{
  \bool_set_false:N \l_fontspec_icu_bool
  \bool_set_true:N \l_fontspec_firsttime_bool
  \xetex_or_luatex:nnn { \cs_set:Npn \fontspec_namewrap:n ##1 }
    { ##1 }
    { name:##1 }
  \tl_clear:N \l_fontspec_optical_size_tl
  \tl_clear:N \l_fontspec_renderer_tl
  \luatex_if_engine:T {
    \tl_set:Nn \l_fontspec_mode_tl {node}
    \luatexprehyphenchar   =`\-  % fixme
    \luatexposthyphenchar  = 0   % fixme
    \luatexpreexhyphenchar = 0   % fixme
    \luatexpostexhyphenchar= 0   % fixme
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_make_smallcaps:T}
% \label{mac:zf@make@smallcaps}
% This macro checks if the font contains small caps, and if so
% creates the string for accessing them in \cmd{\l_fontspec_sc_featstr_sclist}.
%    \begin{macrocode}
\cs_set:Nn \fontspec_make_ot_smallcaps:T {
  \tl_clear:N \l_fontspec_sc_featstr_sclist
  \fontspec_check_ot_feat:nT {+smcp} {
    \tl_set:Nx \l_fontspec_sc_featstr_sclist {+smcp;}
    #1
  }
}
\xetex_or_luatex:nn
{
  \cs_set:Nn \fontspec_make_smallcaps:T {
    \bool_if:NTF \l_fontspec_icu_bool {
      \fontspec_make_ot_smallcaps:T {#1}
    }{
      \bool_if:NT \l_fontspec_atsui_bool {
        \tl_clear:N \l_fontspec_sc_featstr_sclist
        \fontspec_make_AAT_feature_string:nnT {3}{3} {
          \tl_set:Nx \l_fontspec_sc_featstr_sclist
              {\l_fontspec_feature_string_tl;}
          #1
        }
      }
    }
  }
}
{
  \cs_set_eq:NN \fontspec_make_smallcaps:T \fontspec_make_ot_smallcaps:T
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\sclist_put_right:Nn}
% I'm hardly going to write an `sclist' module but a couple of functions are
% useful.
%    \begin{macrocode}
\cs_set_eq:NN \sclist_new:N \tl_new:N
\cs_set_eq:NN \sclist_clear:N \tl_clear:N
\cs_new:Npn \sclist_gput_right:Nn #1#2 {
  \tl_gput_right:Nn #1 {#2;}
}
\cs_generate_variant:Nn \sclist_gput_right:Nn {Nx}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fontspec_update_featstr:n}
% \cmd{\l_fontspec_rawfeatures_sclist} is the string used to define the list of specific
% font features. Each time another font feature is requested, this
% macro is used to add that feature to the list. Font features are
% separated by semicolons.
%    \begin{macrocode}
\cs_new:Nn \fontspec_update_featstr:n {
  \bool_if:NF \l_fontspec_firsttime_bool {
    \sclist_gput_right:Nx \l_fontspec_rawfeatures_sclist {#1;}
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fontspec_make_feature:nnn}
%   This macro is called by each feature key selected, and runs
%   according to which type of font is selected.
%    \begin{macrocode}
\cs_new:Npn \fontspec_make_feature:nnn #1#2#3 {
  \xetex_or_luatex:nn
  {
    \bool_if:NTF \l_fontspec_icu_bool {
      \fontspec_make_ICU_feature:n {#3}
    }{
      \bool_if:NT \l_fontspec_atsui_bool {
        \fontspec_make_AAT_feature:nn {#1}{#2}
      }
    }
  }
  {
    \fontspec_make_ICU_feature:n {#3}
  }
}
\cs_generate_variant:Nn \fontspec_make_feature:nnn {nnx}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \fontspec_make_AAT_feature:nn #1#2 {
  \tl_if_empty:nTF {#1}
  { \fontspec_warning:n {aat-feature-not-exist} }
  {
    \fontspec_make_AAT_feature_string:nnTF {#1}{#2}
    {
      \fontspec_update_fontid:n {+#1,#2}
      \fontspec_update_featstr:n {\l_fontspec_feature_string_tl}
    }
    { \fontspec_warning:nx {aat-feature-not-exist-in-font} {#1,#2} }
  }
}
\cs_new:Npn \fontspec_make_ICU_feature:n #1 {
  \tl_if_empty:nTF {#1}
  { \fontspec_warning:n {icu-feature-not-exist} }
  {
    \fontspec_check_ot_feat:nTF {#1}
    {
      \fontspec_update_fontid:n {#1}
      \fontspec_update_featstr:n{#1}
    }
    { \fontspec_warning:nx {icu-feature-not-exist-in-font} {#1} }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_define_font_feature:n}
% \begin{macro}{\fontspec_define_feature_option:nnnnn}
% These macros are used in order to simplify font feature definition later on.
%    \begin{macrocode}
\cs_new:Nn \fontspec_define_font_feature:n {
  \define@key[zf]{options}{#1}{{\setkeys[zf@feat]{#1}{##1}}}
}
\cs_new:Nn \fontspec_define_feature_option:nnnnn {
  \define@key[zf@feat]{#1}{#2}[]{\fontspec_make_feature:nnn{#3}{#4}{#5}}
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\keyval@alias@key}
% This macro maps one \pkg{xkeyval} key to another.
%    \begin{macrocode}
\newcommand*\keyval@alias@key[4][KV]{
  \cs_set_eq:cc{#1@#2@#4}{#1@#2@#3}
  \cs_set_eq:cc{#1@#2@#4@default}{#1@#2@#3@default}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\multi@alias@key}
% This macro iterates through families to map one key to another,
% regardless of which family it's contained within.
%    \begin{macrocode}
\newcommand*\multi@alias@key[2]{
  \key@ifundefined[zf]{options}{#1}
    {
      \key@ifundefined[zf]{preparse}{#1}
      {
        \key@ifundefined[zf]{preparse-external}{#1}
          { \fontspec_warning:nx {rename-feature-not-exist} {#1} }
          { \keyval@alias@key[zf]{preparse-external}{#1}{#2} }
      }
      { \keyval@alias@key[zf]{preparse}{#1}{#2} }
    }
    { \keyval@alias@key[zf]{options}{#1}{#2} }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_make_AAT_feature_string:nnTF}
%   This macro takes the numerical codes for a font feature and
%   creates a specified macro containing the string required in the
%   font definition to turn that feature on or off. Used primarily in
%   [...], but also used to check if small caps
%   exists in the requested font (see page~\pageref{mac:zf@make@smallcaps}).
%
% For exclusive selectors, it's easy; just grab the string:
% For \emph{non}-exclusive selectors, it's a little more complex.
% If the selector is even, it corresponds to switching the feature on.
% If the selector is \emph{odd}, it corresponds to switching the feature off.
% But \XeTeX\ doesn't return a selector string for this number, since the
% feature is defined for the `switching on' value. So we need to check the
% selector of the previous number, and then prefix the feature string with |!|
% to denote the switch.
%
% Finally, save out the complete feature string in \cmd\l_fontspec_feature_string_tl.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_make_AAT_feature_string:nn {TF,T,F} {
  \tl_set:Nx \l_tmpa_tl { \XeTeXfeaturename \zf@basefont #1 }
  \tl_if_empty:NTF \l_tmpa_tl
  { \prg_return_false: }
  {
    \int_compare:nTF { \XeTeXisexclusivefeature\zf@basefont #1 > 0 }
    {
      \tl_set:Nx \l_tmpb_tl {\XeTeXselectorname\zf@basefont #1\space #2}
    }{
      \int_if_even:nTF {#2}
      {
        \tl_set:Nx \l_tmpb_tl {\XeTeXselectorname\zf@basefont #1\space #2}
      }{
        \tl_set:Nx \l_tmpb_tl {
          \XeTeXselectorname\zf@basefont #1\space \numexpr#2-1\relax
        }
        \tl_if_empty:NF \l_tmpb_tl { \tl_put_left:Nn \l_tmpb_tl {!} }
      }
    }
    \tl_if_empty:NTF \l_tmpb_tl
    { \prg_return_false: }
    {
      \tl_set:Nx \l_fontspec_feature_string_tl { \l_tmpa_tl = \l_tmpb_tl }
      \prg_return_true:
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_iv_str_to_num:Nn}
% \begin{macro}{\fontspec_v_str_to_num:Nn}
% This macro takes a four character string and converts it to the
% numerical representation required for \XeTeX\ OpenType script/language/feature
% purposes. The output is stored in \cmd\l_fontspec_strnum_int.
%
% The reason it's ugly is because the input can be of the form of any of these:
% `|abcd|', `|abc|', `|abc |', `|ab|', `|ab  |', \etc.
% (It is assumed the first two chars are \emph{always} not spaces.) So this macro
% reads in the string, delimited by a space; this input is padded with \cmd\@empty s
% and anything beyond four chars is snipped. The \cmd\@empty s then are used to reconstruct
% the spaces in the string to number calculation.
%
% The variant \cmd\fontspec_v_str_to_num:n\ is used when looking at features, which are passed around
% with prepended plus and minus signs (\eg, \texttt{+liga}, \texttt{-dlig}); it
% simply strips off the first char of the input before calling the normal \cmd\fontspec_iv_str_to_num:n.
%    \begin{macrocode}
\cs_set:Npn \fontspec_iv_str_to_num:Nn #1#2 {
  \fontspec_iv_str_to_num:w #1 \q_nil #2 \@empty \@empty \q_nil
}
\cs_set:Npn \fontspec_iv_str_to_num:w #1 \q_nil #2#3#4#5#6 \q_nil {
  \int_set:Nn #1 {
      `#2 * "1000000
    + `#3 * "10000
    + \ifx \@empty #4 32 \else `#4 \fi * "100
    + \ifx \@empty #5 32 \else `#5 \fi
  }
}
\cs_generate_variant:Nn \fontspec_iv_str_to_num:Nn {No}
\cs_set:Npn \fontspec_v_str_to_num:Nn #1#2 {
  \bool_if:nTF
    {
      \tl_if_head_eq_charcode_p:nN {#2} {+} ||
      \tl_if_head_eq_charcode_p:nN {#2} {-}
    }
    { \fontspec_iv_str_to_num:No #1 { \use_none:n #2 } }
    { \fontspec_iv_str_to_num:Nn #1 {#2} }
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\fontspec_check_script:nTF}
% This macro takes an OpenType script tag and checks if it exists in the current
% font. The output boolean is \cmd\@tempswatrue. \cmd\l_fontspec_strnum_int\ is used to store
% the number corresponding to the script tag string.
%    \begin{macrocode}
\xetex_or_luatex:nnn {\prg_new_conditional:Nnn \fontspec_check_script:n {TF}}
  {
    \fontspec_iv_str_to_num:Nn \l_fontspec_strnum_int {#1}
    \int_set:Nn \l_tmpb_int { \XeTeXOTcountscripts\zf@basefont }
    \int_zero:N \l_tmpa_int
    \@tempswafalse
    \bool_until_do:nn { \int_compare_p:nNn \l_tmpa_int = \l_tmpb_int }
    {
      \ifnum \XeTeXOTscripttag\zf@basefont \l_tmpa_int = \l_fontspec_strnum_int
        \@tempswatrue
        \int_set:Nn \l_tmpa_int {\l_tmpb_int}
      \else
        \int_incr:N \l_tmpa_int
      \fi
    }
    \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
  }
  {
    \directlua{fontspec.check_ot_script("zf@basefont", "#1")}
    \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_check_lang:nTF}
% This macro takes an OpenType language tag and checks if it exists in the current
% font/script. The output boolean is \cmd\@tempswatrue. \cmd\l_fontspec_strnum_int\ is used to store
% the number corresponding to the language tag string.
% The script used is whatever's held in \cmd\l_fontspec_script_int. By default, that's the
% number corresponding to `|latn|'.
%    \begin{macrocode}
\xetex_or_luatex:nnn {\prg_new_conditional:Nnn \fontspec_check_lang:n {TF}}
  {
    \fontspec_iv_str_to_num:Nn \l_fontspec_strnum_int {#1}
    \int_set:Nn \l_tmpb_int {
      \XeTeXOTcountlanguages \zf@basefont \l_fontspec_script_int
    }
    \int_zero:N \l_tmpa_int
    \@tempswafalse
    \bool_until_do:nn { \int_compare_p:nNn \l_tmpa_int = \l_tmpb_int }
    {
      \ifnum\XeTeXOTlanguagetag\zf@basefont\l_fontspec_script_int \l_tmpa_int =\l_fontspec_strnum_int
        \@tempswatrue
        \int_set:Nn \l_tmpa_int {\l_tmpb_int}
      \else
        \int_incr:N \l_tmpa_int
      \fi
    }
    \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
  }
  {
    \directlua{
      fontspec.check_ot_lang( "zf@basefont", "#1", "\l_fontspec_script_tl" )
    }
    \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_check_ot_feat:nTF}
% \begin{macro}{\fontspec_check_ot_feat:nT}
% This macro takes an OpenType feature tag and checks if it exists in the current
% font/script/language.
% The output boolean is \cmd\@tempswa. \cmd\l_fontspec_strnum_int\ is used to store
% the number corresponding to the feature tag string.
% The script used is whatever's held in \cmd\l_fontspec_script_int. By default, that's the
% number corresponding to `|latn|'. The language used is \cmd\l_fontspec_language_int,
% by default |0|, the `default language'.
%    \begin{macrocode}
\xetex_or_luatex:nnn
   { \prg_new_conditional:Nnn \fontspec_check_ot_feat:n {TF,T} }
   {
    \int_set:Nn \l_tmpb_int {
      \XeTeXOTcountfeatures \zf@basefont
                            \l_fontspec_script_int
                            \l_fontspec_language_int
    }
    \fontspec_v_str_to_num:Nn \l_fontspec_strnum_int {#1}
    \int_zero:N \l_tmpa_int
    \@tempswafalse
    \bool_until_do:nn { \int_compare_p:nNn \l_tmpa_int = \l_tmpb_int }
    {
      \ifnum\XeTeXOTfeaturetag\zf@basefont\l_fontspec_script_int\l_fontspec_language_int
           \l_tmpa_int =\l_fontspec_strnum_int
        \@tempswatrue
        \int_set:Nn \l_tmpa_int {\l_tmpb_int}
      \else
        \int_incr:N \l_tmpa_int
      \fi
    }
    \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
  }
  {
    \directlua{
      fontspec.check_ot_feat(
                              "zf@basefont", "#1",
                              "\l_fontspec_lang_tl", "\l_fontspec_script_tl"
                            )
    }
    \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{\pkg{keyval} definitions}
%
% This is the tedious section where we correlate all possible
% (eventually) font feature requests with their \XeTeX\ representations.
%
% \subsubsection{Pre-parsing naming information}
%
% These features are extracted from the font feature list before all others, using
% \pkg{xkeyval}'s \cmd\setkeys|*|.
%
% \paragraph{\feat{ExternalLocation}}
% For fonts that aren't installed in the system. If no argument is given, the font is located
% with |kpsewhich|; it's either in the current directory or the \TeX\ tree. Otherwise, the
% argument given defines the file path of the font.
%    \begin{macrocode}
\bool_new:N \l_fontspec_external_bool
\define@key[zf]{preparse-external}{ExternalLocation}[]{
  \bool_set_true:N \l_fontspec_nobf_bool
  \bool_set_true:N \l_fontspec_noit_bool
  \bool_set_true:N \l_fontspec_external_bool
  \xetex_or_luatex:nnn { \cs_gset:Npn \fontspec_namewrap:n ##1 }
    {     [ #1 ##1 ] }
    { file: #1 ##1   }
  \xetex_if_engine:T { \setkeys[zf]{preparse}{Renderer=ICU} }
}
\aliasfontfeature{ExternalLocation}{Path}
%    \end{macrocode}
%
% \paragraph{\feat{Extension}}
% For fonts that aren't installed in the system. Specifies the font extension
% to use.
%    \begin{macrocode}
\define@key[zf]{preparse-external}{Extension}{
  \tl_set:Nn \l_fontspec_extension_tl {#1}
  \bool_if:NF \l_fontspec_external_bool {
    \setkeys*[zf]{preparse-external}{ExternalLocation}
  }
}
\tl_clear:N \l_fontspec_extension_tl
%    \end{macrocode}
%
% \subsubsection{Pre-parsed features}
%
% After the font name(s) have been sorted out, now need to extract any
% renderer/font configuration features that need to be processed before
% all other font features.
%
% \paragraph{\feat{Renderer}}
% This feature must be processed before all others (the other font shape and features options are also pre-parsed for convenience) because the renderer determines the format of the features and even whether certain features are available.
%    \begin{macrocode}
\define@choicekey[zf]{preparse}{Renderer}[\l_tmpa_tl\l_tmpa_num]
    {AAT,ICU,Graphite,Full,Basic}{
  \fontspec_update_fontid:n {+rend:#1}
  \int_compare:nTF {\l_tmpa_num < 3} {
    \xetex_or_luatex:nn
    {
      \tl_set:Nv \l_fontspec_renderer_tl {g_fontspec_renderer_tag_\l_tmpa_tl}
    }
    {
      \fontspec_warning:nx {only-xetex-feature} {Renderer=AAT/ICU/Graphite}
    }
  }{
    \xetex_or_luatex:nn
    { \fontspec_warning:nx {only-luatex-feature} {Renderer=Full/Basic} }
    { \tl_set:Nv \l_fontspec_mode_tl {g_fontspec_mode_tag_\l_tmpa_tl}  }
  }
}
\tl_set:cn {g_fontspec_renderer_tag_AAT} {/AAT}
\tl_set:cn {g_fontspec_renderer_tag_ICU} {/ICU}
\tl_set:cn {g_fontspec_renderer_tag_Graphite} {/GR}
\tl_set:cn {g_fontspec_mode_tag_Full}  {node}
\tl_set:cn {g_fontspec_mode_tag_Basic} {base}
%    \end{macrocode}
%
% \paragraph{OpenType script/language}
% See later for the resolutions from \pkg{fontspec} features to OpenType definitions.
%    \begin{macrocode}
\define@key[zf]{preparse}{Script}{
  \xetex_if_engine:T { \setkeys[zf]{preparse}{Renderer=ICU} }
  \tl_set:Nn \l_fontspec_script_name_tl {#1}
  \fontspec_update_fontid:n {+script:#1}
}
%    \end{macrocode}
% Exactly the same:
%    \begin{macrocode}
\define@key[zf]{preparse}{Language}{
  \xetex_if_engine:T { \setkeys[zf]{preparse}{Renderer=ICU} }
  \tl_set:Nn \l_fontspec_lang_name_tl {#1}
  \fontspec_update_fontid:n {+language:#1}
}
%    \end{macrocode}
%
% \subsubsection{Bold/italic choosing options}
%
% The \feat{Bold}, \feat{Italic}, and \feat{BoldItalic}
% features are for defining explicitly the bold and italic fonts used
% in a font family.
%
% \paragraph{Fonts}
% Upright:
%    \begin{macrocode}
\define@key[zf]{preparse-external}{UprightFont}{
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_up_tl {#1}
  \fontspec_update_fontid:n {up:#1}
}
%    \end{macrocode}
% Bold:
%    \begin{macrocode}
\define@key[zf]{preparse-external}{BoldFont}{
  \tl_if_empty:nTF {#1}
  {
    \bool_set_true:N \l_fontspec_nobf_bool
    \fontspec_update_fontid:n {nobf}
  }
  {
    \bool_set_false:N \l_fontspec_nobf_bool
    \fontspec_complete_fontname:Nn \l_fontspec_fontname_bf_tl {#1}
    \fontspec_update_fontid:n {bf:#1}
  }
}
%    \end{macrocode}
% Same for italic:
%    \begin{macrocode}
\define@key[zf]{preparse-external}{ItalicFont}{
  \tl_if_empty:nTF {#1}
  {
    \bool_set_true:N \l_fontspec_noit_bool
    \fontspec_update_fontid:n {noit}
  }{
    \bool_set_false:N \l_fontspec_noit_bool
    \fontspec_complete_fontname:Nn \l_fontspec_fontname_it_tl {#1}
    \fontspec_update_fontid:n {it:#1}
  }
}
%    \end{macrocode}
% Simpler for bold+italic \& slanted:
%    \begin{macrocode}
\define@key[zf]{preparse-external}{BoldItalicFont}{
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_bfit_tl {#1}
  \fontspec_update_fontid:n {bfit:#1}
}
\define@key[zf]{preparse-external}{SlantedFont}{
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_sl_tl {#1}
  \fontspec_update_fontid:n {sl:#1}
}
\define@key[zf]{preparse-external}{BoldSlantedFont}{
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_bfsl_tl {#1}
  \fontspec_update_fontid:n {bfsl:#1}
}
%    \end{macrocode}
% Small caps isn't pre-parsed because it can vary with others above:
%    \begin{macrocode}
\define@key[zf]{options}{SmallCapsFont}{
  \tl_if_empty:nTF {#1}
  {
    \bool_set_true:N \l_fontspec_nosc_bool
    \fontspec_update_fontid:n {nosc}
  }{
    \bool_set_true:N \l_fontspec_nosc_bool
    \fontspec_complete_fontname:Nn \l_fontspec_fontname_sc_tl {#1}
    \fontspec_update_fontid:n {sc:\zap@space #1~\@empty}
  }
}
%    \end{macrocode}
%
% \begin{macro}{\fontspec_complete_fontname:Nn}
% This macro defines |#1| as the input with any |*| tokens of its input
% replaced by the font name. This lets us define supplementary fonts in full
% (``\texttt{Baskerville Semibold}'') or in abbreviation (``\texttt{* Semibold}'').
%    \begin{macrocode}
\cs_set:Npn \fontspec_complete_fontname:Nn #1#2 {
  \tl_set:Nn #1 {#2}
  \tl_replace_all_in:Nnx #1 {*} {\l_fontspec_fontname_tl}
  \luatex_if_engine:T {
    \tl_replace_all_in:Nnn #1 {~} {}
  }
}
\cs_generate_variant:Nn \tl_replace_all_in:Nnn {Nnx}
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Features}
%    \begin{macrocode}
\define@key[zf]{preparse}{UprightFeatures}{
  \def\l_fontspec_fontfeat_up_clist{, #1}
  \fontspec_update_fontid:n {rmfeat:#1}
}
\define@key[zf]{preparse}{BoldFeatures}{
  \def\l_fontspec_fontfeat_bf_clist{, #1}
  \fontspec_update_fontid:n {bffeat:#1}
}
\define@key[zf]{preparse}{ItalicFeatures}{
  \def\l_fontspec_fontfeat_it_clist{, #1}
  \fontspec_update_fontid:n {itfeat:#1}
}
\define@key[zf]{preparse}{BoldItalicFeatures}{
  \def\l_fontspec_fontfeat_bfit_clist{, #1}
  \fontspec_update_fontid:n {bfitfeat:#1}
}
\define@key[zf]{preparse}{SlantedFeatures}{
  \def\l_fontspec_fontfeat_sl_clist{, #1}
  \fontspec_update_fontid:n {slfeat:#1}
}
\define@key[zf]{preparse}{BoldSlantedFeatures}{
  \def\l_fontspec_fontfeat_bfsl_clist{, #1}
  \fontspec_update_fontid:n {bfslfeat:#1}
}
%    \end{macrocode}
% Note that small caps features can vary by shape, so these in fact \emph{aren't} pre-parsed.
%    \begin{macrocode}
\define@key[zf]{options}{SmallCapsFeatures}{
  \bool_if:NF \l_fontspec_firsttime_bool {
    \def\l_fontspec_fontfeat_sc_clist{, #1}
  }
  \fontspec_update_fontid:n {scfeat:\zap@space #1~\@empty}
}
%    \end{macrocode}
%
% paragraph{Features varying by size}
% TODO: sizezfeatures and italicfont (etc) don't play nice
%    \begin{macrocode}
\define@key[zf]{preparse}{SizeFeatures}{
  \tl_set:Nn \l_fontspec_sizefeat_clist {#1}
  \fontspec_update_fontid:n {sizefeat:\zap@space #1~\@empty}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\define@key[zf]{sizing}{Size}{ \tl_set:Nn \l_fontspec_size_tl {#1} }
\define@key[zf]{sizing}{Font}{
  \fontspec_complete_fontname:Nn \l_fontspec_sizedfont_tl {#1}
}
%    \end{macrocode}
%
% \subsubsection{Font-independent features}
%
% These features can be applied to any font.
%
% \paragraph{Scale}
% If the input isn't one of the pre-defined string options, then
% it's gotta be numerical. \cs{fontspec_calc_scale:n} does all the work in
% the auto-scaling cases.
%    \begin{macrocode}
\define@key[zf]{options}{Scale}{
  \prg_case_str:nnn {#1}
  {
    {MatchLowercase} { \fontspec_calc_scale:n {5} }
    {MatchUppercase} { \fontspec_calc_scale:n {8} }
  }
  { \tl_set:Nx \l_fontspec_scale_tl {#1} }
  \fontspec_update_fontid:n {+scale:\l_fontspec_scale_tl}
  \tl_set:Nx \l_fontspec_scale_tl { s*[\l_fontspec_scale_tl] }
}
%    \end{macrocode}
%
% \begin{macro}{\fontspec_calc_scale:n}
% This macro calculates the amount of scaling between the default
% roman font and the (default shape of) the font being selected such
% that the font dimension that is input is equal for both. The only
% font dimensions that justify this are 5 (lowercase height)
% and 8 (uppercase height in \XeTeX).
%
% This script is executed for every extra shape, which seems wasteful,
% but allows alternate italic shapes from a separate font, say, to
% be loaded and to be auto-scaled correctly. Even if this would be ugly.
%    \begin{macrocode}
\cs_new:Npn \fontspec_calc_scale:n #1 {
  \group_begin:
    \rmfamily
    \fontspec_set_font_dimen:NnN \@tempdima {#1} \font
    \fontspec_set_font_dimen:NnN \@tempdimb {#1} \zf@basefont
    \dim_set:Nn \@tempdimc { 1pt*\@tempdima/\@tempdimb }
    \tl_gset:Nx \l_fontspec_scale_tl {\strip@pt\@tempdimc}
    \fontspec_info:n {set-scale}
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_set_font_dimen:NnN}
% This function sets the dimension |#1| (for font |#3|) to `fontdimen' |#2|
% for either font dimension 5 (x-height) or 8 (cap-height). If, for some
% reason, these return an incorrect `zero' value (as \cs{fontdimen8} might
% for a \texttt{.tfm} font), then we cheat and measure the height of a glyph.
% We assume in this case that the font contains either an `X' or an `x'.
%    \begin{macrocode}
\cs_new:Npn \fontspec_set_font_dimen:NnN #1#2#3
{
  \dim_set:Nn #1 { \fontdimen #2 #3 }
  \dim_compare:nNnT #1 = {0pt} {
    \settoheight #1 {
      \str_if_eq:nnTF {#3} {\font} \rmfamily #3
      \prg_case_int:nnn #2 {
        {5} {x} % x-height
        {8} {X} % cap-height
      } {?} % "else" clause; never reached.
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Inter-word space}
% These options set the relevant \cmd\fontdimen s for the
% font being loaded.
%    \begin{macrocode}
\define@key[zf]{options}{WordSpace}{
  \fontspec_update_fontid:n {+wordspace:#1}
  \bool_if:NF \l_fontspec_firsttime_bool {
    \_fontspec_parse_wordspace:w #1,,,\q_stop
  }
}
%    \end{macrocode}
%
% \begin{macro}{\zf@wordspace@parse}
% This macro determines if the input to \feat{WordSpace} is
% of the form |{X}| or |{X,Y,Z}| and executes the font scaling.
% If the former input, it executes |{X,X,X}|.
%    \begin{macrocode}
\cs_set:Npn \_fontspec_parse_wordspace:w #1,#2,#3,#4 \q_stop {
  \tl_if_empty:nTF {#4}
  {
    \dim_set:Nn \@tempdima {#1\fontdimen2\zf@basefont}
    \dim_set:Nn \@tempdimb {\@tempdima}
    \dim_set:Nn \@tempdimc {\@tempdima}
  }{
    \dim_set:Nn \@tempdima {#1\fontdimen2\zf@basefont}
    \dim_set:Nn \@tempdimb {#2\fontdimen3\zf@basefont}
    \dim_set:Nn \@tempdimc {#3\fontdimen4\zf@basefont}
  }
  \tl_set:Nx \l_fontspec_postadjust_tl {
    \l_fontspec_postadjust_tl
    \fontdimen2\font\the\@tempdima
    \fontdimen3\font\the\@tempdimb
    \fontdimen4\font\the\@tempdimc
  }
}
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Punctuation space}
% Scaling factor for the nominal \cmd\fontdimen \#7.
%    \begin{macrocode}
\define@key[zf]{options}{PunctuationSpace}{
  \fontspec_update_fontid:n {+punctspace:#1}
  \setlength\@tempdima{#1\fontdimen7\zf@basefont}
  \tl_set:Nx \l_fontspec_postadjust_tl {\l_fontspec_postadjust_tl\fontdimen7\font\the\@tempdima}
}
%    \end{macrocode}
%
% \paragraph{Letterspacing}
%    \begin{macrocode}
\define@key[zf]{options}{LetterSpace}{
  \fontspec_update_fontid:n {+tracking:#1}
  \fontspec_update_featstr:n{letterspace=#1}
}
%    \end{macrocode}
%
% \paragraph{Hyphenation character}
% This feature takes one of three arguments: `\opt{None}',
% \meta{glyph}, or \meta{slot}. If the input isn't the first,
% and it's one character, then it's the second; otherwise, it's
% the third.
%    \begin{macrocode}
\define@key[zf]{options}{HyphenChar}{
  \fontspec_update_fontid:n {+hyphenchar:#1}
  \str_if_eq:nnTF {#1} {None}
  {
    \tl_put_right:Nn \l_fontspec_postadjust_tl { \hyphenchar \font = \c_minus_one }
  }
  {
    \tl_if_single:nTF {#1}
      { \tl_set:Nn \l_fontspec_hyphenchar_tl {`#1} }
      { \tl_set:Nn \l_fontspec_hyphenchar_tl { #1} }
    \font_glyph_if_exist:NnTF \zf@basefont {\l_fontspec_hyphenchar_tl}
    {
      \xetex_or_luatex:nnn { \tl_put_right:Nn \l_fontspec_postadjust_tl }
        { \hyphenchar \font = \l_fontspec_hyphenchar_tl \scan_stop: }
        {
          \hyphenchar \font = \c_zero
          \luatexprehyphenchar = \l_fontspec_hyphenchar_tl \scan_stop:
        }
    }
    { \fontspec_error:nx {no-glyph}{#1} }
  }
}
%    \end{macrocode}
%
% \paragraph{Color}
%    \begin{macrocode}
\define@key[zf]{options}{Color}{
  \fontspec_update_fontid:n {+col:#1}
  \cs_if_exist:cTF {\token_to_str:N\color@#1}
  {
    \convertcolorspec{named}{#1}{HTML}\l_fontspec_hexcol_tl
  }
  {
    \int_compare:nTF { \tl_elt_count:n {#1} == 6 }
    { \tl_set:Nn \l_fontspec_hexcol_tl {#1} }
    {
      \int_compare:nTF { \tl_elt_count:n {#1} == 8 }
      { \fontspec_parse_colour:viii #1 }
      {
        \bool_if:NF \l_fontspec_firsttime_bool {
          \fontspec_warning:nx {bad-colour} {#1}
        }
      }
    }
  }
}
\cs_set:Npn \fontspec_parse_colour:viii #1#2#3#4#5#6#7#8 {
  \tl_set:Nn \l_fontspec_hexcol_tl {#1#2#3#4#5#6}
  \tl_if_eq:NNF \l_fontspec_opacity_tl \g_fontspec_opacity_tl
   {
    \bool_if:NF \l_fontspec_firsttime_bool {
      \fontspec_warning:nx {opa-twice-col} {#7#8}
    }
   }
  \tl_set:Nn \l_fontspec_opacity_tl {#7#8}
}
\keyval@alias@key[zf]{options}{Color}{Colour}
%    \end{macrocode}
%    \begin{macrocode}
\newcounter{fontspec_tmp_int}
\define@key[zf]{options}{Opacity}{
  \fontspec_update_fontid:n {+opac:#1}
  \setcounter {fontspec_tmp_int} { 255*\real{#1} }
  \tl_if_eq:NNF \l_fontspec_opacity_tl \g_fontspec_opacity_tl
   {
    \bool_if:NF \l_fontspec_firsttime_bool {
      \fontspec_warning:nx {opa-twice} {#1}
    }
   }
  \tl_set:Nx \l_fontspec_opacity_tl
   { \nhex2 { \value{fontspec_tmp_int} } }
}
%    \end{macrocode}
%
%
% \paragraph{Mapping}
%    \begin{macrocode}
\xetex_or_luatex:nnn {
  \define@key[zf]{options}{Mapping}
}{
  \fontspec_update_fontid:n {+map:#1}
  \fontspec_update_featstr:n{mapping=#1}
}{
  \str_if_eq:nnTF {#1} {tex-text} {
    \fontspec_warning:n {no-mapping-ligtex}
    \msg_redirect_name:nnn {fontspec} {no-mapping-ligtex} {none}
    \setkeys[zf]{options}{ Ligatures=TeX }
  }{
    \fontspec_warning:n {no-mapping}
  }
}
%    \end{macrocode}
%
% \paragraph{FeatureFile}
%    \begin{macrocode}
\define@key[zf]{options}{FeatureFile}{
  \fontspec_update_fontid:n {+fea:#1}
  \fontspec_update_featstr:n{featurefile=#1}
}
%    \end{macrocode}
%
%
% \subsubsection{Continuous font axes}
%
%    \begin{macrocode}
\define@key[zf]{options}{Weight}{
  \fontspec_update_fontid:n {+weight:#1}
  \fontspec_update_featstr:n{weight=#1}
}
\define@key[zf]{options}{Width}{
  \fontspec_update_fontid:n {+width:#1}
  \fontspec_update_featstr:n{width=#1}
}
\define@key[zf]{options}{OpticalSize}{
  \xetex_or_luatex:nn {
    \bool_if:NTF \l_fontspec_icu_bool {
      \tl_set:Nn \l_fontspec_optical_size_tl {/ S = #1}
      \fontspec_update_fontid:n {+size:#1}
    }{
      \bool_if:NT \l_fontspec_mm_bool {
        \fontspec_update_fontid:n {+size:#1}
        \fontspec_update_featstr:n{optical size=#1}
      }
    }
    \bool_if:nT { !\l_fontspec_icu_bool && !\l_fontspec_mm_bool }{
      \bool_if:NT \l_fontspec_firsttime_bool {
        \fontspec_warning:n {no-opticals}
      }
    }
  }{
    \tl_set:Nn \l_fontspec_optical_size_tl {/ S = #1}
    \fontspec_update_fontid:n {+size:#1}
  }
}
%    \end{macrocode}
%
% \subsubsection{Font transformations}
% These are to be specified to apply directly to a font shape:
%    \begin{macrocode}
\define@key[zf]{options}{FakeSlant}[0.2]{
  \fontspec_update_fontid:n {+slant:#1}
  \fontspec_update_featstr:n{slant=#1}
}
\define@key[zf]{options}{FakeStretch}[1.2]{
  \fontspec_update_fontid:n {+extend:#1}
  \fontspec_update_featstr:n{extend=#1}
}
\define@key[zf]{options}{FakeBold}[1.5]{
  \fontspec_update_fontid:n {+embolden:#1}
  \fontspec_update_featstr:n{embolden=#1}
}
%    \end{macrocode}
% These are to be given to a shape that has no real bold/italic
% to signal that \pkg{fontspec} should automatically create `fake' shapes.
%
% The behaviour is currently that only if both \opt{AutoFakeSlant} \emph{and}
% \opt{AutoFakeBold} are specified, the bold italic is also faked.
%
% These features presently \emph{override} real shapes found in the font;
% in the future I'd like these features to be ignored in this case, instead.
% (This is just a bit harder to program in the current design of
% \pkg{fontspec}.)
%    \begin{macrocode}
\define@key[zf]{options}{AutoFakeSlant}[0.2]{
  \bool_if:NT \l_fontspec_firsttime_bool {
    \tl_set:Nn \l_fontspec_fake_slant_tl {#1}
    \clist_put_right:Nn \l_fontspec_fontfeat_it_clist {,FakeSlant=#1}
    \tl_set_eq:NN \l_fontspec_fontname_it_tl \l_fontspec_fontname_tl
    \fontspec_update_fontid:n {fakeit:#1}
    \tl_if_empty:NF \l_fontspec_fake_embolden_tl {
      \tl_put_right:Nx \l_fontspec_fontfeat_bfit_clist
        {,FakeBold=\l_fontspec_fake_embolden_tl,FakeSlant=#1}
      \tl_set_eq:NN \l_fontspec_fontname_bfit_tl \l_fontspec_fontname_tl
    }
  }
}
%    \end{macrocode}
% Same but reversed:
%    \begin{macrocode}
\define@key[zf]{options}{AutoFakeBold}[1.5]{
  \bool_if:NT \l_fontspec_firsttime_bool {
    \tl_set:Nn \l_fontspec_fake_embolden_tl {#1}
    \tl_put_right:Nn \l_fontspec_fontfeat_bf_clist {,FakeBold=#1}
    \tl_set_eq:NN \l_fontspec_fontname_bf_tl \l_fontspec_fontname_tl
    \fontspec_update_fontid:n {fakebf:#1}
    \tl_if_empty:NF \l_fontspec_fake_slant_tl {
      \tl_put_right:Nx \l_fontspec_fontfeat_bfit_clist
        {,FakeSlant=\l_fontspec_fake_slant_tl,FakeBold=#1}
      \tl_set_eq:NN \l_fontspec_fontname_bfit_tl \l_fontspec_fontname_tl
    }
  }
}
%    \end{macrocode}
%
%
% \subsubsection{Ligatures}
% The call to the nested keyval family must be wrapped in braces to
% hide the parent list (this later requires the use of global
% definitions (|\xdef|) in [...]). Both \AAT\ and OpenType
% names are offered to chose |Rare|/|Discretionary| ligatures.
%    \begin{macrocode}
\fontspec_define_font_feature:n{Ligatures}
\fontspec_define_feature_option:nnnnn{Ligatures}{Required}       {1}{0}{+rlig}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoRequired}     {1}{1}{-rlig}
\fontspec_define_feature_option:nnnnn{Ligatures}{Common}         {1}{2}{+liga}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoCommon}       {1}{3}{-liga}
\fontspec_define_feature_option:nnnnn{Ligatures}{Rare}           {1}{4}{+dlig}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoRare}         {1}{5}{-dlig}
\fontspec_define_feature_option:nnnnn{Ligatures}{Discretionary}  {1}{4}{+dlig}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoDiscretionary}{1}{5}{-dlig}
\fontspec_define_feature_option:nnnnn{Ligatures}{Contextual}     {}{}  {+clig}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoContextual}   {}{}  {-clig}
\fontspec_define_feature_option:nnnnn{Ligatures}{Historic}       {}{}  {+hlig}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoHistoric}     {}{}  {-hlig}
\fontspec_define_feature_option:nnnnn{Ligatures}{Logos}          {1}{6} {}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoLogos}        {1}{7} {}
\fontspec_define_feature_option:nnnnn{Ligatures}{Rebus}          {1}{8} {}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoRebus}        {1}{9} {}
\fontspec_define_feature_option:nnnnn{Ligatures}{Diphthong}      {1}{10}{}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoDiphthong}    {1}{11}{}
\fontspec_define_feature_option:nnnnn{Ligatures}{Squared}        {1}{12}{}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoSquared}      {1}{13}{}
\fontspec_define_feature_option:nnnnn{Ligatures}{AbbrevSquared}  {1}{14}{}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoAbbrevSquared}{1}{15}{}
\fontspec_define_feature_option:nnnnn{Ligatures}{Icelandic}      {1}{32}{}
\fontspec_define_feature_option:nnnnn{Ligatures}{NoIcelandic}    {1}{33}{}
%    \end{macrocode}
% Emulate CM extra ligatures.
%    \begin{macrocode}
\define@key[zf@feat]{Ligatures}{TeX}[]{
  \xetex_or_luatex:nn {
    \fontspec_update_fontid:n {+map:tex-text}
    \fontspec_update_featstr:n{mapping=tex-text}
  }{
    \fontspec_update_fontid:n {+tlig+trep}
    \fontspec_update_featstr:n{+tlig;+trep}
  }
}
%    \end{macrocode}
%
% \subsubsection{Letters}
%    \begin{macrocode}
\fontspec_define_font_feature:n{Letters}
\fontspec_define_feature_option:nnnnn{Letters}{Normal}             {3}{0}{}
\fontspec_define_feature_option:nnnnn{Letters}{Uppercase}          {3}{1}{+case}
\fontspec_define_feature_option:nnnnn{Letters}{Lowercase}          {3}{2}{}
\fontspec_define_feature_option:nnnnn{Letters}{SmallCaps}          {3}{3}{+smcp}
\fontspec_define_feature_option:nnnnn{Letters}{PetiteCaps}         {} {} {+pcap}
\fontspec_define_feature_option:nnnnn{Letters}{UppercaseSmallCaps} {} {} {+c2sc}
\fontspec_define_feature_option:nnnnn{Letters}{UppercasePetiteCaps}{} {} {+c2pc}
\fontspec_define_feature_option:nnnnn{Letters}{InitialCaps}        {3}{4}{}
\fontspec_define_feature_option:nnnnn{Letters}{Unicase}            {} {} {+unic}
%    \end{macrocode}
%
% \subsubsection{Numbers}
%
% These were originally separated into \feat{NumberCase} and
% \feat{NumberSpacing} following \AAT, but it makes more sense to
% combine them.
%
% Both naming conventions are offered to select the number case.
%
%    \begin{macrocode}
\fontspec_define_font_feature:n{Numbers}
\fontspec_define_feature_option:nnnnn{Numbers}{Monospaced}   {6} {0}{+tnum}
\fontspec_define_feature_option:nnnnn{Numbers}{Proportional} {6} {1}{+pnum}
\fontspec_define_feature_option:nnnnn{Numbers}{Lowercase}    {21}{0}{+onum}
\fontspec_define_feature_option:nnnnn{Numbers}{OldStyle}     {21}{0}{+onum}
\fontspec_define_feature_option:nnnnn{Numbers}{Uppercase}    {21}{1}{+lnum}
\fontspec_define_feature_option:nnnnn{Numbers}{Lining}       {21}{1}{+lnum}
\fontspec_define_feature_option:nnnnn{Numbers}{SlashedZero}  {14}{5}{+zero}
\fontspec_define_feature_option:nnnnn{Numbers}{NoSlashedZero}{14}{4}{-zero}
%    \end{macrocode}
%
% |luaotload| provides a custom |anum| feature for replacing Latin
% (AKA Arabic) numbers with Arabic (AKA Indic-Arabic). The same feature
% maps to Farsi (Persian) numbers if font language is Farsi.
%
%    \begin{macrocode}
\luatex_if_engine:T {
  \fontspec_define_feature_option:nnnnn{Numbers}{Arabic}{}{}{+anum}
}
%    \end{macrocode}
%
% \subsubsection{Contextuals}
%    \begin{macrocode}
\fontspec_define_font_feature:n  {Contextuals}
\fontspec_define_feature_option:nnnnn{Contextuals}{Swash}        {} {} {+cswh}
\fontspec_define_feature_option:nnnnn{Contextuals}{NoSwash}      {} {} {-cswh}
\fontspec_define_feature_option:nnnnn{Contextuals}{Alternate}    {} {} {+calt}
\fontspec_define_feature_option:nnnnn{Contextuals}{NoAlternate}  {} {} {-calt}
\fontspec_define_feature_option:nnnnn{Contextuals}{WordInitial}  {8}{0}{+init}
\fontspec_define_feature_option:nnnnn{Contextuals}{NoWordInitial}{8}{1}{-init}
\fontspec_define_feature_option:nnnnn{Contextuals}{WordFinal}    {8}{2}{+fina}
\fontspec_define_feature_option:nnnnn{Contextuals}{NoWordFinal}  {8}{3}{-fina}
\fontspec_define_feature_option:nnnnn{Contextuals}{LineInitial}  {8}{4}{}
\fontspec_define_feature_option:nnnnn{Contextuals}{NoLineInitial}{8}{5}{}
\fontspec_define_feature_option:nnnnn{Contextuals}{LineFinal}    {8}{6}{+falt}
\fontspec_define_feature_option:nnnnn{Contextuals}{NoLineFinal}  {8}{7}{-falt}
\fontspec_define_feature_option:nnnnn{Contextuals}{Inner}        {8}{8}{+medi}
\fontspec_define_feature_option:nnnnn{Contextuals}{NoInner}      {8}{9}{-medi}
%    \end{macrocode}
%
% \subsubsection{Diacritics}
%    \begin{macrocode}
\fontspec_define_font_feature:n{Diacritics}
\fontspec_define_feature_option:nnnnn{Diacritics}{Show}        {9}{0}{}
\fontspec_define_feature_option:nnnnn{Diacritics}{Hide}        {9}{1}{}
\fontspec_define_feature_option:nnnnn{Diacritics}{Decompose}   {9}{2}{}
\fontspec_define_feature_option:nnnnn{Diacritics}{MarkToBase}  {}{}{+mark}
\fontspec_define_feature_option:nnnnn{Diacritics}{NoMarkToBase}{}{}{-mark}
\fontspec_define_feature_option:nnnnn{Diacritics}{MarkToMark}  {}{}{+mkmk}
\fontspec_define_feature_option:nnnnn{Diacritics}{NoMarkToMark}{}{}{-mkmk}
\fontspec_define_feature_option:nnnnn{Diacritics}{AboveBase}   {}{}{+abvm}
\fontspec_define_feature_option:nnnnn{Diacritics}{NoAboveBase} {}{}{-abvm}
\fontspec_define_feature_option:nnnnn{Diacritics}{BelowBase}   {}{}{+blwm}
\fontspec_define_feature_option:nnnnn{Diacritics}{NoBelowBase} {}{}{-blwm}
%    \end{macrocode}
%
% \subsubsection{Kerning}
%    \begin{macrocode}
\fontspec_define_font_feature:n{Kerning}
\fontspec_define_feature_option:nnnnn{Kerning}{Uppercase}{}{}{+cpsp}
\fontspec_define_feature_option:nnnnn{Kerning}{On}       {}{}{+kern}
\fontspec_define_feature_option:nnnnn{Kerning}{Off}      {}{}{-kern}
%\fontspec_define_feature_option:nnnnn{Kerning}{Vertical}{}{}{+vkrn}
%\fontspec_define_feature_option:nnnnn{Kerning}
%    {VerticalAlternateProportional}{}{}{+vpal}
%\fontspec_define_feature_option:nnnnn{Kerning}{VerticalAlternateHalfWidth}{}{}{+vhal}
%    \end{macrocode}
%
% \subsubsection{Vertical position}
%    \begin{macrocode}
\fontspec_define_font_feature:n{VerticalPosition}
\fontspec_define_feature_option:nnnnn{VerticalPosition}{Normal}     {10}{0}{}
\fontspec_define_feature_option:nnnnn{VerticalPosition}{Superior}   {10}{1}{+sups}
\fontspec_define_feature_option:nnnnn{VerticalPosition}{Inferior}   {10}{2}{+subs}
\fontspec_define_feature_option:nnnnn{VerticalPosition}{Ordinal}    {10}{3}{+ordn}
\fontspec_define_feature_option:nnnnn{VerticalPosition}{Numerator}  {}  {} {+numr}
\fontspec_define_feature_option:nnnnn{VerticalPosition}{Denominator}{}  {} {+dnom}
\fontspec_define_feature_option:nnnnn{VerticalPosition}{ScientificInferior}{}{}{+sinf}
%    \end{macrocode}
%
% \subsubsection{Fractions}
%    \begin{macrocode}
\fontspec_define_font_feature:n{Fractions}
\fontspec_define_feature_option:nnnnn{Fractions}{On}       {11}{1}{+frac}
\fontspec_define_feature_option:nnnnn{Fractions}{Off}      {11}{0}{-frac}
\fontspec_define_feature_option:nnnnn{Fractions}{Diagonal} {11}{2}{}
\fontspec_define_feature_option:nnnnn{Fractions}{Alternate}{}  {} {+afrc}
%    \end{macrocode}
%
% \subsubsection{Alternates and variants}
% Selected numerically because they don't have standard names. Very
% easy to process, very annoying for the user!
%
%    \begin{macrocode}
\define@key[zf]{options}{Alternate}[0]{
  \clist_set_eq:NN \l_fontspec_tmpa_clist \XKV@rm
  \setkeys*[zf@feat]{Alternate}{#1}
  \tl_if_empty:NF \XKV@rm {
    \def\XKV@tfam{Alternate}
    \fontspec_make_feature:nnx {17}{#1} { \fontspec_salt:n {#1} }
  }
  \clist_set_eq:NN \XKV@rm \l_fontspec_tmpa_clist
}
%    \end{macrocode}
%
%    \begin{macrocode}
\xetex_or_luatex:nnn { \cs_set:Npn \fontspec_salt:n #1 }
  {+salt=#1} { +salt= \int_eval:n {#1+1} }
%    \end{macrocode}
%
%    \begin{macrocode}
\define@key[zf]{options}{Variant}{
  \clist_set_eq:NN \l_fontspec_tmpa_clist \XKV@rm
  \setkeys*[zf@feat]{Variant}{#1}
  \tl_if_empty:NF \XKV@rm {
    \def\XKV@tfam{Variant}
    \fontspec_make_feature:nnx {18}{#1} { +ss \two@digits {#1} }
  }
  \clist_set_eq:NN \XKV@rm \l_fontspec_tmpa_clist
}
\aliasfontfeature{Variant}{StylisticSet}
%    \end{macrocode}
%
%    \begin{macrocode}
\define@key[zf]{options}{CharacterVariant}{
  \clist_set_eq:NN \l_fontspec_tmpa_clist \XKV@rm
  \setkeys*[zf@feat]{CharacterVariant}{#1}
  \tl_if_empty:NF \XKV@rm {
    \def\XKV@tfam{CharacterVariant}
    \fontspec_make_feature:nnx {}{} { +cv \two@digits {#1} }
  }
  \clist_set_eq:NN \XKV@rm \l_fontspec_tmpa_clist
}
%    \end{macrocode}
%
% \subsubsection{Style}
%    \begin{macrocode}
\fontspec_define_font_feature:n{Style}
\fontspec_define_feature_option:nnnnn{Style}{Alternate}     {}  {} {+salt}
\fontspec_define_feature_option:nnnnn{Style}{Italic}        {32}{2}{+ital}
\fontspec_define_feature_option:nnnnn{Style}{Ruby}          {28}{2}{+ruby}
\fontspec_define_feature_option:nnnnn{Style}{Swash}         {}  {} {+swsh}
\fontspec_define_feature_option:nnnnn{Style}{Historic}      {}  {} {+hist}
\fontspec_define_feature_option:nnnnn{Style}{Display}       {19}{1}{}
\fontspec_define_feature_option:nnnnn{Style}{Engraved}      {19}{2}{}
\fontspec_define_feature_option:nnnnn{Style}{TitlingCaps}   {19}{4}{+titl}
\fontspec_define_feature_option:nnnnn{Style}{TallCaps}      {19}{5}{}
\fontspec_define_feature_option:nnnnn{Style}{HorizontalKana}{}  {} {+hkna}
\fontspec_define_feature_option:nnnnn{Style}{VerticalKana}  {}  {} {+vkna}
%    \end{macrocode}
%
% \subsubsection{CJK shape}
%    \begin{macrocode}
\fontspec_define_font_feature:n{CJKShape}
\fontspec_define_feature_option:nnnnn{CJKShape}{Traditional}{20}{0} {+trad}
\fontspec_define_feature_option:nnnnn{CJKShape}{Simplified} {20}{1} {+smpl}
\fontspec_define_feature_option:nnnnn{CJKShape}{JIS1978}    {20}{2} {+jp78}
\fontspec_define_feature_option:nnnnn{CJKShape}{JIS1983}    {20}{3} {+jp83}
\fontspec_define_feature_option:nnnnn{CJKShape}{JIS1990}    {20}{4} {+jp90}
\fontspec_define_feature_option:nnnnn{CJKShape}{Expert}     {20}{10}{+expt}
\fontspec_define_feature_option:nnnnn{CJKShape}{NLC}        {20}{13}{+nlck}
%    \end{macrocode}
%
% \subsubsection{Character width}
%    \begin{macrocode}
\fontspec_define_font_feature:n{CharacterWidth}
\fontspec_define_feature_option:nnnnn{CharacterWidth}{Proportional}{22}{0}{+pwid}
\fontspec_define_feature_option:nnnnn{CharacterWidth}{Full}{22}{1}{+fwid}
\fontspec_define_feature_option:nnnnn{CharacterWidth}{Half}{22}{2}{+hwid}
\fontspec_define_feature_option:nnnnn{CharacterWidth}{Third}{22}{3}{+twid}
\fontspec_define_feature_option:nnnnn{CharacterWidth}{Quarter}{22}{4}{+qwid}
\fontspec_define_feature_option:nnnnn{CharacterWidth}{AlternateProportional}{22}{5}{+palt}
\fontspec_define_feature_option:nnnnn{CharacterWidth}{AlternateHalf}{22}{6}{+halt}
\fontspec_define_feature_option:nnnnn{CharacterWidth}{Default}{22}{7}{}
%    \end{macrocode}
%
% \subsubsection{Annotation}
%    \begin{macrocode}
\fontspec_define_feature_option:nnnnn{Annotation}{Off}{24}{0}{}
\fontspec_define_feature_option:nnnnn{Annotation}{Box}{24}{1}{}
\fontspec_define_feature_option:nnnnn{Annotation}{RoundedBox}{24}{2}{}
\fontspec_define_feature_option:nnnnn{Annotation}{Circle}{24}{3}{}
\fontspec_define_feature_option:nnnnn{Annotation}{BlackCircle}{24}{4}{}
\fontspec_define_feature_option:nnnnn{Annotation}{Parenthesis}{24}{5}{}
\fontspec_define_feature_option:nnnnn{Annotation}{Period}{24}{6}{}
\fontspec_define_feature_option:nnnnn{Annotation}{RomanNumerals}{24}{7}{}
\fontspec_define_feature_option:nnnnn{Annotation}{Diamond}{24}{8}{}
\fontspec_define_feature_option:nnnnn{Annotation}{BlackSquare}{24}{9}{}
\fontspec_define_feature_option:nnnnn{Annotation}{BlackRoundSquare}{24}{10}{}
\fontspec_define_feature_option:nnnnn{Annotation}{DoubleCircle}{24}{11}{}
%    \end{macrocode}
%
%    \begin{macrocode}
\define@key[zf]{options}{Annotation}[0]{
  \clist_set_eq:NN \l_fontspec_tmpa_clist \XKV@rm
  \setkeys*[zf@feat]{Annotation}{#1}
  \tl_if_empty:NF \XKV@rm {
    \def\XKV@tfam{Alternate}
    \fontspec_make_feature:nnx {}{} { \fontspec_nalt:n {#1} }
  }
  \clist_set_eq:NN \XKV@rm \l_fontspec_tmpa_clist
}
%    \end{macrocode}
%
%    \begin{macrocode}
\xetex_or_luatex:nnn { \cs_set:Npn \fontspec_nalt:n #1 }
  {+nalt=#1} { +nalt= \int_eval:n {#1+1} }
%    \end{macrocode}
%
% \subsubsection{Vertical}
%    \begin{macrocode}
\fontspec_define_font_feature:n{Vertical}
\define@key[zf@feat]{Vertical}{RotatedGlyphs}[]{
  \bool_if:NTF \l_fontspec_icu_bool {
    \fontspec_make_feature:nnn{}{}{+vrt2}
    \fontspec_update_fontid:n {+vert}
    \fontspec_update_featstr:n{vertical}
  }{
    \fontspec_update_fontid:n {+vert}
    \fontspec_update_featstr:n{vertical}
  }
}
%    \end{macrocode}
%
% \subsubsection{Script}
%    \begin{macrocode}
\newfontscript{Arabic}{arab}            \newfontscript{Armenian}{armn}
\newfontscript{Balinese}{bali}          \newfontscript{Bengali}{beng}
\newfontscript{Bopomofo}{bopo}          \newfontscript{Braille}{brai}
\newfontscript{Buginese}{bugi}          \newfontscript{Buhid}{buhd}
\newfontscript{Byzantine~Music}{byzm} \newfontscript{Canadian~Syllabics}{cans}
\newfontscript{Cherokee}{cher}
\newfontscript{CJK~Ideographic}{hani}   \newfontscript{Coptic}{copt}
\newfontscript{Cypriot~Syllabary}{cprt} \newfontscript{Cyrillic}{cyrl}
\newfontscript{Default}{DFLT}           \newfontscript{Deseret}{dsrt}
\newfontscript{Devanagari}{deva}        \newfontscript{Ethiopic}{ethi}
\newfontscript{Georgian}{geor}          \newfontscript{Glagolitic}{glag}
\newfontscript{Gothic}{goth}            \newfontscript{Greek}{grek}
\newfontscript{Gujarati}{gujr}          \newfontscript{Gurmukhi}{guru}
\newfontscript{Hangul~Jamo}{jamo}       \newfontscript{Hangul}{hang}
\newfontscript{Hanunoo}{hano}           \newfontscript{Hebrew}{hebr}
\newfontscript{Hiragana~and~Katakana}{kana}
\newfontscript{Javanese}{java}          \newfontscript{Kannada}{knda}
\newfontscript{Kharosthi}{khar}         \newfontscript{Khmer}{khmr}
\newfontscript{Lao}{lao~}               \newfontscript{Latin}{latn}
\newfontscript{Limbu}{limb}             \newfontscript{Linear~B}{linb}
\newfontscript{Malayalam}{mlym}         \newfontscript{Math}{math}
\newfontscript{Mongolian}{mong}
\newfontscript{Musical~Symbols}{musc}   \newfontscript{Myanmar}{mymr}
\newfontscript{N'ko}{nko~}              \newfontscript{Ogham}{ogam}
\newfontscript{Old~Italic}{ital}
\newfontscript{Old~Persian~Cuneiform}{xpeo}
\newfontscript{Oriya}{orya}             \newfontscript{Osmanya}{osma}
\newfontscript{Phags-pa}{phag}          \newfontscript{Phoenician}{phnx}
\newfontscript{Runic}{runr}             \newfontscript{Shavian}{shaw}
\newfontscript{Sinhala}{sinh}
\newfontscript{Sumero-Akkadian~Cuneiform}{xsux}
\newfontscript{Syloti~Nagri}{sylo}      \newfontscript{Syriac}{syrc}
\newfontscript{Tagalog}{tglg}           \newfontscript{Tagbanwa}{tagb}
\newfontscript{Tai~Le}{tale}            \newfontscript{Tai~Lu}{talu}
\newfontscript{Tamil}{taml}             \newfontscript{Telugu}{telu}
\newfontscript{Thaana}{thaa}            \newfontscript{Thai}{thai}
\newfontscript{Tibetan}{tibt}           \newfontscript{Tifinagh}{tfng}
\newfontscript{Ugaritic~Cuneiform}{ugar}\newfontscript{Yi}{yi~~}
%    \end{macrocode}
% For convenience:
%    \begin{macrocode}
\newfontscript{Kana}{kana}
\newfontscript{Maths}{math}
\newfontscript{CJK}{hani}
%    \end{macrocode}
%
% \subsubsection{Language}
%    \begin{macrocode}
\newfontlanguage{Abaza}{ABA}\newfontlanguage{Abkhazian}{ABK}
\newfontlanguage{Adyghe}{ADY}\newfontlanguage{Afrikaans}{AFK}
\newfontlanguage{Afar}{AFR}\newfontlanguage{Agaw}{AGW}
\newfontlanguage{Altai}{ALT}\newfontlanguage{Amharic}{AMH}
\newfontlanguage{Arabic}{ARA}\newfontlanguage{Aari}{ARI}
\newfontlanguage{Arakanese}{ARK}\newfontlanguage{Assamese}{ASM}
\newfontlanguage{Athapaskan}{ATH}\newfontlanguage{Avar}{AVR}
\newfontlanguage{Awadhi}{AWA}\newfontlanguage{Aymara}{AYM}
\newfontlanguage{Azeri}{AZE}\newfontlanguage{Badaga}{BAD}
\newfontlanguage{Baghelkhandi}{BAG}\newfontlanguage{Balkar}{BAL}
\newfontlanguage{Baule}{BAU}\newfontlanguage{Berber}{BBR}
\newfontlanguage{Bench}{BCH}\newfontlanguage{Bible~Cree}{BCR}
\newfontlanguage{Belarussian}{BEL}\newfontlanguage{Bemba}{BEM}
\newfontlanguage{Bengali}{BEN}\newfontlanguage{Bulgarian}{BGR}
\newfontlanguage{Bhili}{BHI}\newfontlanguage{Bhojpuri}{BHO}
\newfontlanguage{Bikol}{BIK}\newfontlanguage{Bilen}{BIL}
\newfontlanguage{Blackfoot}{BKF}\newfontlanguage{Balochi}{BLI}
\newfontlanguage{Balante}{BLN}\newfontlanguage{Balti}{BLT}
\newfontlanguage{Bambara}{BMB}\newfontlanguage{Bamileke}{BML}
\newfontlanguage{Breton}{BRE}\newfontlanguage{Brahui}{BRH}
\newfontlanguage{Braj~Bhasha}{BRI}\newfontlanguage{Burmese}{BRM}
\newfontlanguage{Bashkir}{BSH}\newfontlanguage{Beti}{BTI}
\newfontlanguage{Catalan}{CAT}\newfontlanguage{Cebuano}{CEB}
\newfontlanguage{Chechen}{CHE}\newfontlanguage{Chaha~Gurage}{CHG}
\newfontlanguage{Chattisgarhi}{CHH}\newfontlanguage{Chichewa}{CHI}
\newfontlanguage{Chukchi}{CHK}\newfontlanguage{Chipewyan}{CHP}
\newfontlanguage{Cherokee}{CHR}\newfontlanguage{Chuvash}{CHU}
\newfontlanguage{Comorian}{CMR}\newfontlanguage{Coptic}{COP}
\newfontlanguage{Cree}{CRE}\newfontlanguage{Carrier}{CRR}
\newfontlanguage{Crimean~Tatar}{CRT}\newfontlanguage{Church~Slavonic}{CSL}
\newfontlanguage{Czech}{CSY}\newfontlanguage{Danish}{DAN}
\newfontlanguage{Dargwa}{DAR}\newfontlanguage{Woods~Cree}{DCR}
\newfontlanguage{German}{DEU}
\newfontlanguage{Dogri}{DGR}\newfontlanguage{Divehi}{DIV}
\newfontlanguage{Djerma}{DJR}\newfontlanguage{Dangme}{DNG}
\newfontlanguage{Dinka}{DNK}\newfontlanguage{Dungan}{DUN}
\newfontlanguage{Dzongkha}{DZN}\newfontlanguage{Ebira}{EBI}
\newfontlanguage{Eastern~Cree}{ECR}\newfontlanguage{Edo}{EDO}
\newfontlanguage{Efik}{EFI}\newfontlanguage{Greek}{ELL}
\newfontlanguage{English}{ENG}\newfontlanguage{Erzya}{ERZ}
\newfontlanguage{Spanish}{ESP}\newfontlanguage{Estonian}{ETI}
\newfontlanguage{Basque}{EUQ}\newfontlanguage{Evenki}{EVK}
\newfontlanguage{Even}{EVN}\newfontlanguage{Ewe}{EWE}
\newfontlanguage{French~Antillean}{FAN}
\newfontlanguage{Farsi}{FAR}
\newfontlanguage{Parsi}{FAR}
\newfontlanguage{Persian}{FAR}
\newfontlanguage{Finnish}{FIN}\newfontlanguage{Fijian}{FJI}
\newfontlanguage{Flemish}{FLE}\newfontlanguage{Forest~Nenets}{FNE}
\newfontlanguage{Fon}{FON}\newfontlanguage{Faroese}{FOS}
\newfontlanguage{French}{FRA}\newfontlanguage{Frisian}{FRI}
\newfontlanguage{Friulian}{FRL}\newfontlanguage{Futa}{FTA}
\newfontlanguage{Fulani}{FUL}\newfontlanguage{Ga}{GAD}
\newfontlanguage{Gaelic}{GAE}\newfontlanguage{Gagauz}{GAG}
\newfontlanguage{Galician}{GAL}\newfontlanguage{Garshuni}{GAR}
\newfontlanguage{Garhwali}{GAW}\newfontlanguage{Ge'ez}{GEZ}
\newfontlanguage{Gilyak}{GIL}\newfontlanguage{Gumuz}{GMZ}
\newfontlanguage{Gondi}{GON}\newfontlanguage{Greenlandic}{GRN}
\newfontlanguage{Garo}{GRO}\newfontlanguage{Guarani}{GUA}
\newfontlanguage{Gujarati}{GUJ}\newfontlanguage{Haitian}{HAI}
\newfontlanguage{Halam}{HAL}\newfontlanguage{Harauti}{HAR}
\newfontlanguage{Hausa}{HAU}\newfontlanguage{Hawaiin}{HAW}
\newfontlanguage{Hammer-Banna}{HBN}\newfontlanguage{Hiligaynon}{HIL}
\newfontlanguage{Hindi}{HIN}\newfontlanguage{High~Mari}{HMA}
\newfontlanguage{Hindko}{HND}\newfontlanguage{Ho}{HO}
\newfontlanguage{Harari}{HRI}\newfontlanguage{Croatian}{HRV}
\newfontlanguage{Hungarian}{HUN}\newfontlanguage{Armenian}{HYE}
\newfontlanguage{Igbo}{IBO}\newfontlanguage{Ijo}{IJO}
\newfontlanguage{Ilokano}{ILO}\newfontlanguage{Indonesian}{IND}
\newfontlanguage{Ingush}{ING}\newfontlanguage{Inuktitut}{INU}
\newfontlanguage{Irish}{IRI}\newfontlanguage{Irish~Traditional}{IRT}
\newfontlanguage{Icelandic}{ISL}\newfontlanguage{Inari~Sami}{ISM}
\newfontlanguage{Italian}{ITA}\newfontlanguage{Hebrew}{IWR}
\newfontlanguage{Javanese}{JAV}\newfontlanguage{Yiddish}{JII}
\newfontlanguage{Japanese}{JAN}\newfontlanguage{Judezmo}{JUD}
\newfontlanguage{Jula}{JUL}\newfontlanguage{Kabardian}{KAB}
\newfontlanguage{Kachchi}{KAC}\newfontlanguage{Kalenjin}{KAL}
\newfontlanguage{Kannada}{KAN}\newfontlanguage{Karachay}{KAR}
\newfontlanguage{Georgian}{KAT}\newfontlanguage{Kazakh}{KAZ}
\newfontlanguage{Kebena}{KEB}\newfontlanguage{Khutsuri~Georgian}{KGE}
\newfontlanguage{Khakass}{KHA}\newfontlanguage{Khanty-Kazim}{KHK}
\newfontlanguage{Khmer}{KHM}\newfontlanguage{Khanty-Shurishkar}{KHS}
\newfontlanguage{Khanty-Vakhi}{KHV}\newfontlanguage{Khowar}{KHW}
\newfontlanguage{Kikuyu}{KIK}\newfontlanguage{Kirghiz}{KIR}
\newfontlanguage{Kisii}{KIS}\newfontlanguage{Kokni}{KKN}
\newfontlanguage{Kalmyk}{KLM}\newfontlanguage{Kamba}{KMB}
\newfontlanguage{Kumaoni}{KMN}\newfontlanguage{Komo}{KMO}
\newfontlanguage{Komso}{KMS}\newfontlanguage{Kanuri}{KNR}
\newfontlanguage{Kodagu}{KOD}\newfontlanguage{Korean~Old~Hangul}{KOH}
\newfontlanguage{Konkani}{KOK}\newfontlanguage{Kikongo}{KON}
\newfontlanguage{Komi-Permyak}{KOP}\newfontlanguage{Korean}{KOR}
\newfontlanguage{Komi-Zyrian}{KOZ}\newfontlanguage{Kpelle}{KPL}
\newfontlanguage{Krio}{KRI}\newfontlanguage{Karakalpak}{KRK}
\newfontlanguage{Karelian}{KRL}\newfontlanguage{Karaim}{KRM}
\newfontlanguage{Karen}{KRN}\newfontlanguage{Koorete}{KRT}
\newfontlanguage{Kashmiri}{KSH}\newfontlanguage{Khasi}{KSI}
\newfontlanguage{Kildin~Sami}{KSM}\newfontlanguage{Kui}{KUI}
\newfontlanguage{Kulvi}{KUL}\newfontlanguage{Kumyk}{KUM}
\newfontlanguage{Kurdish}{KUR}\newfontlanguage{Kurukh}{KUU}
\newfontlanguage{Kuy}{KUY}\newfontlanguage{Koryak}{KYK}
\newfontlanguage{Ladin}{LAD}\newfontlanguage{Lahuli}{LAH}
\newfontlanguage{Lak}{LAK}\newfontlanguage{Lambani}{LAM}
\newfontlanguage{Lao}{LAO}\newfontlanguage{Latin}{LAT}
\newfontlanguage{Laz}{LAZ}\newfontlanguage{L-Cree}{LCR}
\newfontlanguage{Ladakhi}{LDK}\newfontlanguage{Lezgi}{LEZ}
\newfontlanguage{Lingala}{LIN}\newfontlanguage{Low~Mari}{LMA}
\newfontlanguage{Limbu}{LMB}\newfontlanguage{Lomwe}{LMW}
\newfontlanguage{Lower~Sorbian}{LSB}\newfontlanguage{Lule~Sami}{LSM}
\newfontlanguage{Lithuanian}{LTH}\newfontlanguage{Luba}{LUB}
\newfontlanguage{Luganda}{LUG}\newfontlanguage{Luhya}{LUH}
\newfontlanguage{Luo}{LUO}\newfontlanguage{Latvian}{LVI}
\newfontlanguage{Majang}{MAJ}\newfontlanguage{Makua}{MAK}
\newfontlanguage{Malayalam~Traditional}{MAL}\newfontlanguage{Mansi}{MAN}
\newfontlanguage{Marathi}{MAR}\newfontlanguage{Marwari}{MAW}
\newfontlanguage{Mbundu}{MBN}\newfontlanguage{Manchu}{MCH}
\newfontlanguage{Moose~Cree}{MCR}\newfontlanguage{Mende}{MDE}
\newfontlanguage{Me'en}{MEN}\newfontlanguage{Mizo}{MIZ}
\newfontlanguage{Macedonian}{MKD}\newfontlanguage{Male}{MLE}
\newfontlanguage{Malagasy}{MLG}\newfontlanguage{Malinke}{MLN}
\newfontlanguage{Malayalam~Reformed}{MLR}\newfontlanguage{Malay}{MLY}
\newfontlanguage{Mandinka}{MND}\newfontlanguage{Mongolian}{MNG}
\newfontlanguage{Manipuri}{MNI}\newfontlanguage{Maninka}{MNK}
\newfontlanguage{Manx~Gaelic}{MNX}\newfontlanguage{Moksha}{MOK}
\newfontlanguage{Moldavian}{MOL}\newfontlanguage{Mon}{MON}
\newfontlanguage{Moroccan}{MOR}\newfontlanguage{Maori}{MRI}
\newfontlanguage{Maithili}{MTH}\newfontlanguage{Maltese}{MTS}
\newfontlanguage{Mundari}{MUN}\newfontlanguage{Naga-Assamese}{NAG}
\newfontlanguage{Nanai}{NAN}\newfontlanguage{Naskapi}{NAS}
\newfontlanguage{N-Cree}{NCR}\newfontlanguage{Ndebele}{NDB}
\newfontlanguage{Ndonga}{NDG}\newfontlanguage{Nepali}{NEP}
\newfontlanguage{Newari}{NEW}\newfontlanguage{Nagari}{NGR}
\newfontlanguage{Norway~House~Cree}{NHC}\newfontlanguage{Nisi}{NIS}
\newfontlanguage{Niuean}{NIU}\newfontlanguage{Nkole}{NKL}
\newfontlanguage{N'ko}{NKO}\newfontlanguage{Dutch}{NLD}
\newfontlanguage{Nogai}{NOG}\newfontlanguage{Norwegian}{NOR}
\newfontlanguage{Northern~Sami}{NSM}\newfontlanguage{Northern~Tai}{NTA}
\newfontlanguage{Esperanto}{NTO}\newfontlanguage{Nynorsk}{NYN}
\newfontlanguage{Oji-Cree}{OCR}\newfontlanguage{Ojibway}{OJB}
\newfontlanguage{Oriya}{ORI}\newfontlanguage{Oromo}{ORO}
\newfontlanguage{Ossetian}{OSS}\newfontlanguage{Palestinian~Aramaic}{PAA}
\newfontlanguage{Pali}{PAL}\newfontlanguage{Punjabi}{PAN}
\newfontlanguage{Palpa}{PAP}\newfontlanguage{Pashto}{PAS}
\newfontlanguage{Polytonic~Greek}{PGR}\newfontlanguage{Pilipino}{PIL}
\newfontlanguage{Palaung}{PLG}\newfontlanguage{Polish}{PLK}
\newfontlanguage{Provencal}{PRO}\newfontlanguage{Portuguese}{PTG}
\newfontlanguage{Chin}{QIN}\newfontlanguage{Rajasthani}{RAJ}
\newfontlanguage{R-Cree}{RCR}\newfontlanguage{Russian~Buriat}{RBU}
\newfontlanguage{Riang}{RIA}\newfontlanguage{Rhaeto-Romanic}{RMS}
\newfontlanguage{Romanian}{ROM}\newfontlanguage{Romany}{ROY}
\newfontlanguage{Rusyn}{RSY}\newfontlanguage{Ruanda}{RUA}
\newfontlanguage{Russian}{RUS}\newfontlanguage{Sadri}{SAD}
\newfontlanguage{Sanskrit}{SAN}\newfontlanguage{Santali}{SAT}
\newfontlanguage{Sayisi}{SAY}\newfontlanguage{Sekota}{SEK}
\newfontlanguage{Selkup}{SEL}\newfontlanguage{Sango}{SGO}
\newfontlanguage{Shan}{SHN}\newfontlanguage{Sibe}{SIB}
\newfontlanguage{Sidamo}{SID}\newfontlanguage{Silte~Gurage}{SIG}
\newfontlanguage{Skolt~Sami}{SKS}\newfontlanguage{Slovak}{SKY}
\newfontlanguage{Slavey}{SLA}\newfontlanguage{Slovenian}{SLV}
\newfontlanguage{Somali}{SML}\newfontlanguage{Samoan}{SMO}
\newfontlanguage{Sena}{SNA}\newfontlanguage{Sindhi}{SND}
\newfontlanguage{Sinhalese}{SNH}\newfontlanguage{Soninke}{SNK}
\newfontlanguage{Sodo~Gurage}{SOG}\newfontlanguage{Sotho}{SOT}
\newfontlanguage{Albanian}{SQI}\newfontlanguage{Serbian}{SRB}
\newfontlanguage{Saraiki}{SRK}\newfontlanguage{Serer}{SRR}
\newfontlanguage{South~Slavey}{SSL}\newfontlanguage{Southern~Sami}{SSM}
\newfontlanguage{Suri}{SUR}\newfontlanguage{Svan}{SVA}
\newfontlanguage{Swedish}{SVE}\newfontlanguage{Swadaya~Aramaic}{SWA}
\newfontlanguage{Swahili}{SWK}\newfontlanguage{Swazi}{SWZ}
\newfontlanguage{Sutu}{SXT}\newfontlanguage{Syriac}{SYR}
\newfontlanguage{Tabasaran}{TAB}\newfontlanguage{Tajiki}{TAJ}
\newfontlanguage{Tamil}{TAM}\newfontlanguage{Tatar}{TAT}
\newfontlanguage{TH-Cree}{TCR}\newfontlanguage{Telugu}{TEL}
\newfontlanguage{Tongan}{TGN}\newfontlanguage{Tigre}{TGR}
\newfontlanguage{Tigrinya}{TGY}\newfontlanguage{Thai}{THA}
\newfontlanguage{Tahitian}{THT}\newfontlanguage{Tibetan}{TIB}
\newfontlanguage{Turkmen}{TKM}\newfontlanguage{Temne}{TMN}
\newfontlanguage{Tswana}{TNA}\newfontlanguage{Tundra~Nenets}{TNE}
\newfontlanguage{Tonga}{TNG}\newfontlanguage{Todo}{TOD}
\newfontlanguage{Tsonga}{TSG}\newfontlanguage{Turoyo~Aramaic}{TUA}
\newfontlanguage{Tulu}{TUL}\newfontlanguage{Tuvin}{TUV}
\newfontlanguage{Twi}{TWI}\newfontlanguage{Udmurt}{UDM}
\newfontlanguage{Ukrainian}{UKR}\newfontlanguage{Urdu}{URD}
\newfontlanguage{Upper~Sorbian}{USB}\newfontlanguage{Uyghur}{UYG}
\newfontlanguage{Uzbek}{UZB}\newfontlanguage{Venda}{VEN}
\newfontlanguage{Vietnamese}{VIT}\newfontlanguage{Wa}{WA}
\newfontlanguage{Wagdi}{WAG}\newfontlanguage{West-Cree}{WCR}
\newfontlanguage{Welsh}{WEL}\newfontlanguage{Wolof}{WLF}
\newfontlanguage{Tai~Lue}{XBD}\newfontlanguage{Xhosa}{XHS}
\newfontlanguage{Yakut}{YAK}\newfontlanguage{Yoruba}{YBA}
\newfontlanguage{Y-Cree}{YCR}\newfontlanguage{Yi~Classic}{YIC}
\newfontlanguage{Yi~Modern}{YIM}\newfontlanguage{Chinese~Hong~Kong}{ZHH}
\newfontlanguage{Chinese~Phonetic}{ZHP}\newfontlanguage{Chinese~Simplified}{ZHS}
\newfontlanguage{Chinese~Traditional}{ZHT}\newfontlanguage{Zande}{ZND}
\newfontlanguage{Zulu}{ZUL}
%    \end{macrocode}
%
% \paragraph{Turkish} Turns out that many fonts use `TUR' as their Turkish language tag rather than the specified `TRK'. So we check for both:
%    \begin{macrocode}
\define@key[zf@feat]{Lang}{Turkish}[]{
  \fontspec_check_lang:nTF {TRK} {
    \int_set:Nn \l_fontspec_language_int {\l_fontspec_strnum_int}
    \fontspec_update_fontid:n {+lang=Turkish}
    \tl_set:Nn \l_fontspec_lang_tl {TRK}
  }{
    \fontspec_check_lang:nTF {TUR} {
      \int_set:Nn \l_fontspec_language_int {\l_fontspec_strnum_int}
      \fontspec_update_fontid:n {+lang=Turkish}
      \tl_set:Nn \l_fontspec_lang_tl {TUR}
    }{
      \fontspec_warning:nx {language-not-exist} {#1}
      \setkeys[zf@feat]{Lang}{Default}
    }
  }
}
%    \end{macrocode}
%
% \paragraph{Default}
%
%    \begin{macrocode}
\define@key[zf@feat]{Lang}{Default}[]{
  \fontspec_update_fontid:n {+lang=dflt}
  \tl_set:Nn \l_fontspec_lang_tl {DFLT}
  \int_zero:N \l_fontspec_language_int
}
%    \end{macrocode}
%
% \subsubsection{Raw feature string}
% This allows savvy \XeTeX-ers to input font features manually if they have
% already memorised the OpenType abbreviations and don't mind not having error checking.
%    \begin{macrocode}
\define@key[zf]{options}{RawFeature}{
  \fontspec_update_fontid:n {+Raw:#1}
  \fontspec_update_featstr:n{#1}
}
%    \end{macrocode}
%
%
%
% \subsection{Italic small caps} \label{sec:sishape}
% The following code for utilising italic small caps sensibly is
% inspired from Philip Lehman's \textit{The Font Installation
%   Guide}. Note that |\upshape| needs to be used \emph{twice} to get
% from italic small caps to regular upright (it always goes to small
% caps, then regular upright).
% \begin{macro}{\sishape}
% \begin{macro}{\textsi}
%     First, the commands for actually selecting italic small caps are
%     defined. I use |si| as the NFSS shape for italic small caps, but
%     I have seen |itsc| and |slsc| also used. |\sidefault| may be
%     redefined to one of these if required for compatibility.
%    \begin{macrocode}
\providecommand*{\sidefault}{si}
\DeclareRobustCommand{\sishape}{
  \not@math@alphabet\sishape\relax
  \fontshape\sidefault\selectfont
}
\DeclareTextFontCommand{\textsi}{\sishape}
%    \end{macrocode}
% \end{macro} \end{macro}
% \begin{macro}{\fontspec_blend_shape:nnn}
%   This is the macro which enables the overload on the |\..shape|
%   commands. It takes three such arguments. In essence, the macro
%   selects the first argument, unless the second argument is already
%   selected, in which case it selects the third.
%    \begin{macrocode}
\cs_new:Nn \fontspec_blend_shape:nnn {
  \bool_if:nTF
  {
    \str_if_eq_p:xx {\f@shape} {#2} &&
    \cs_if_exist_p:c {\f@encoding/\f@family/\f@series/#3}
  }
  { \fontshape{#3}\selectfont }
  { \fontshape{#1}\selectfont }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\itshape} \begin{macro}{\scshape} \begin{macro}{\upshape}
%       Here the original |\..shape| commands are redefined to use the
%       merge shape macro.
%    \begin{macrocode}
\DeclareRobustCommand \itshape {
  \not@math@alphabet\itshape\mathit
  \fontspec_blend_shape:nnn\itdefault\scdefault\sidefault
}
\DeclareRobustCommand \slshape {
  \not@math@alphabet\slshape\relax
  \fontspec_blend_shape:nnn\sldefault\scdefault\sidefault
}
\DeclareRobustCommand \scshape {
  \not@math@alphabet\scshape\relax
  \fontspec_blend_shape:nnn\scdefault\itdefault\sidefault
}
\DeclareRobustCommand \upshape {
  \not@math@alphabet\upshape\relax
  \fontspec_blend_shape:nnn\updefault\sidefault\scdefault
}
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
%
% \subsection{Selecting maths fonts}
% Here, the fonts used in math mode are redefined to correspond to the
% default roman, sans serif and typewriter fonts. Unfortunately, you
% can only define maths fonts in the preamble, otherwise I'd run this
% code whenever \cs{setmainfont} and friends was run.
%
% \begin{macro}{\fontspec_setup_maths:}
% Everything here is performed \cs{AtBeginDocument} in order to
% overwrite \pkg{euler}'s attempt. This means \pkg{fontspec} must be
% loaded \emph{after} \pkg{euler}. We set up a conditional to return
% an error if this rule is violated.
%
% Since every maths setup is slightly different, we also take
% different paths for defining various math glyphs depending which
% maths font package has been loaded.
%
%    \begin{macrocode}
\@ifpackageloaded{euler}{
  \bool_set_true:N \g_fontspec_package_euler_loaded_bool
}{
  \bool_set_false:N \g_fontspec_package_euler_loaded_bool
}
\cs_set:Nn \fontspec_setup_maths: {
  \@ifpackageloaded{euler}{
    \bool_if:NTF \g_fontspec_package_euler_loaded_bool {
      \bool_set_true:N \g_fontspec_math_euler_bool
    }{
      \fontspec_error:n {euler-too-late}
    }
  }{}
  \@ifpackageloaded{lucbmath}{\bool_set_true:N \g_fontspec_math_lucida_bool}{}
  \@ifpackageloaded{lucidabr}{\bool_set_true:N \g_fontspec_math_lucida_bool}{}
  \@ifpackageloaded{lucimatx}{\bool_set_true:N \g_fontspec_math_lucida_bool}{}
%    \end{macrocode}
% Knuth's CM fonts fonts are all squashed together, combining letters,
% accents, text symbols and maths symbols all in the one font,
% \texttt{cmr}, plus other things in other fonts. Because we are
% changing the roman font in the document, we need to redefine all of
% the maths glyphs in \LaTeX's \texttt{operators} maths font to still
% go back to the legacy \texttt{cmr} font for all these random glyphs,
% unless a separate maths font package has been loaded instead.
%
% In every case, the maths accents are always taken from the
% \texttt{operators} font, which is generally the main text
% font. (Actually, there is a \cmd\hat\ accent in
% \texttt{EulerFractur}, but it's \emph{ugly}. So I ignore it. Sorry
% if this causes inconvenience.)
%    \begin{macrocode}
  \DeclareSymbolFont{legacymaths}{OT1}{cmr}{m}{n}
  \SetSymbolFont{legacymaths}{bold}{OT1}{cmr}{bx}{n}
  \DeclareMathAccent{\acute}   {\mathalpha}{legacymaths}{19}
  \DeclareMathAccent{\grave}   {\mathalpha}{legacymaths}{18}
  \DeclareMathAccent{\ddot}    {\mathalpha}{legacymaths}{127}
  \DeclareMathAccent{\tilde}   {\mathalpha}{legacymaths}{126}
  \DeclareMathAccent{\bar}     {\mathalpha}{legacymaths}{22}
  \DeclareMathAccent{\breve}   {\mathalpha}{legacymaths}{21}
  \DeclareMathAccent{\check}   {\mathalpha}{legacymaths}{20}
  \DeclareMathAccent{\hat}     {\mathalpha}{legacymaths}{94} % too bad, euler
  \DeclareMathAccent{\dot}     {\mathalpha}{legacymaths}{95}
  \DeclareMathAccent{\mathring}{\mathalpha}{legacymaths}{23}
%    \end{macrocode}
% \paragraph{\cmd\colon: what's going on?} Okay, so \verb":" and \cmd\colon\ in maths mode are defined in a few places, so I need to work out what does what. Respectively, we have:
% \begin{Verbatim}
% % fontmath.ltx:
% \DeclareMathSymbol{\colon}{\mathpunct}{operators}{"3A}
% \DeclareMathSymbol{:}{\mathrel}{operators}{"3A}
%
% % amsmath.sty:
% \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
%  \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}
%
% % euler.sty:
% \DeclareMathSymbol{:}\mathrel  {EulerFraktur}{"3A}
%
% % lucbmath.sty:
% \DeclareMathSymbol{\@tempb}{\mathpunct}{operators}{58}
% \ifx\colon\@tempb
%   \DeclareMathSymbol{\colon}{\mathpunct}{operators}{58}
% \fi
% \DeclareMathSymbol{:}{\mathrel}{operators}{58}
% \end{Verbatim}
% ($\mathrm{3A_{16}}=\mathrm{58_{10}}$) So I think, based on this summary, that it is fair to tell \pkg{fontspec} to `replace' the operators font with legacymaths for this symbol, except when \pkg{amsmath} is loaded since we want to keep its definition.
%
%
%    \begin{macrocode}
  \group_begin:
    \mathchardef\@tempa="603A \relax
    \ifx\colon\@tempa
      \DeclareMathSymbol{\colon}{\mathpunct}{legacymaths}{58}
    \fi
  \group_end:
%    \end{macrocode}
% The following symbols are only defined specifically in \pkg{euler}, so skip them
% if that package is loaded.
%    \begin{macrocode}
  \bool_if:NF \g_fontspec_math_euler_bool {
    \DeclareMathSymbol{!}{\mathclose}{legacymaths}{33}
    \DeclareMathSymbol{:}{\mathrel}  {legacymaths}{58}
    \DeclareMathSymbol{;}{\mathpunct}{legacymaths}{59}
    \DeclareMathSymbol{?}{\mathclose}{legacymaths}{63}
%    \end{macrocode}
% And these ones are defined both in \pkg{euler} and \pkg{lucbmath},
% so we only need to run this code if no extra maths package has been
% loaded.
%    \begin{macrocode}
    \bool_if:NF \g_fontspec_math_lucida_bool {
      \DeclareMathSymbol{0}{\mathalpha}{legacymaths}{`0}
      \DeclareMathSymbol{1}{\mathalpha}{legacymaths}{`1}
      \DeclareMathSymbol{2}{\mathalpha}{legacymaths}{`2}
      \DeclareMathSymbol{3}{\mathalpha}{legacymaths}{`3}
      \DeclareMathSymbol{4}{\mathalpha}{legacymaths}{`4}
      \DeclareMathSymbol{5}{\mathalpha}{legacymaths}{`5}
      \DeclareMathSymbol{6}{\mathalpha}{legacymaths}{`6}
      \DeclareMathSymbol{7}{\mathalpha}{legacymaths}{`7}
      \DeclareMathSymbol{8}{\mathalpha}{legacymaths}{`8}
      \DeclareMathSymbol{9}{\mathalpha}{legacymaths}{`9}
      \DeclareMathSymbol{\Gamma}{\mathalpha}{legacymaths}{0}
      \DeclareMathSymbol{\Delta}{\mathalpha}{legacymaths}{1}
      \DeclareMathSymbol{\Theta}{\mathalpha}{legacymaths}{2}
      \DeclareMathSymbol{\Lambda}{\mathalpha}{legacymaths}{3}
      \DeclareMathSymbol{\Xi}{\mathalpha}{legacymaths}{4}
      \DeclareMathSymbol{\Pi}{\mathalpha}{legacymaths}{5}
      \DeclareMathSymbol{\Sigma}{\mathalpha}{legacymaths}{6}
      \DeclareMathSymbol{\Upsilon}{\mathalpha}{legacymaths}{7}
      \DeclareMathSymbol{\Phi}{\mathalpha}{legacymaths}{8}
      \DeclareMathSymbol{\Psi}{\mathalpha}{legacymaths}{9}
      \DeclareMathSymbol{\Omega}{\mathalpha}{legacymaths}{10}
      \DeclareMathSymbol{+}{\mathbin}{legacymaths}{43}
      \DeclareMathSymbol{=}{\mathrel}{legacymaths}{61}
      \DeclareMathDelimiter{(}{\mathopen} {legacymaths}{40}{largesymbols}{0}
      \DeclareMathDelimiter{)}{\mathclose}{legacymaths}{41}{largesymbols}{1}
      \DeclareMathDelimiter{[}{\mathopen} {legacymaths}{91}{largesymbols}{2}
      \DeclareMathDelimiter{]}{\mathclose}{legacymaths}{93}{largesymbols}{3}
      \DeclareMathDelimiter{/}{\mathord}{legacymaths}{47}{largesymbols}{14}
      \DeclareMathSymbol{\mathdollar}{\mathord}{legacymaths}{36}
    }
  }
%    \end{macrocode}
% Finally, we change the font definitions for \cmd\mathrm\ and so
% on. These are defined using the \cmd\g_fontspec_mathrm_tl\ (\dots) macros,
% which default to \cmd\rmdefault\ but may be specified with the
% \cmd\setmathrm\ (\dots) commands in the preamble.
%
% Since \LaTeX\ only generally defines one level of boldness, we omit
% \cmd\mathbf\ in the \textsf{bold} maths series. It can be specified
% as per usual with \cmd\setboldmathrm, which stores the appropriate
% family name in \cmd\g_fontspec_bfmathrm_tl.
%    \begin{macrocode}
  \DeclareSymbolFont{operators}\zf@enc\g_fontspec_mathrm_tl\mddefault\updefault
  \SetSymbolFont{operators}{normal}\zf@enc\g_fontspec_mathrm_tl\mddefault\updefault
  \SetMathAlphabet\mathrm{normal}\zf@enc\g_fontspec_mathrm_tl\mddefault\updefault
  \SetMathAlphabet\mathit{normal}\zf@enc\g_fontspec_mathrm_tl\mddefault\itdefault
  \SetMathAlphabet\mathbf{normal}\zf@enc\g_fontspec_mathrm_tl\bfdefault\updefault
  \SetMathAlphabet\mathsf{normal}\zf@enc\g_fontspec_mathsf_tl\mddefault\updefault
  \SetMathAlphabet\mathtt{normal}\zf@enc\g_fontspec_mathtt_tl\mddefault\updefault
  \SetSymbolFont{operators}{bold}\zf@enc\g_fontspec_mathrm_tl\bfdefault\updefault
  \tl_if_empty:NTF \g_fontspec_bfmathrm_tl {
    \SetMathAlphabet\mathrm{bold}\zf@enc\g_fontspec_mathrm_tl\bfdefault\updefault
    \SetMathAlphabet\mathit{bold}\zf@enc\g_fontspec_mathrm_tl\bfdefault\itdefault
  }{
    \SetMathAlphabet\mathrm{bold}\zf@enc\g_fontspec_bfmathrm_tl\mddefault\updefault
    \SetMathAlphabet\mathbf{bold}\zf@enc\g_fontspec_bfmathrm_tl\bfdefault\updefault
    \SetMathAlphabet\mathit{bold}\zf@enc\g_fontspec_bfmathrm_tl\mddefault\itdefault
  }
  \SetMathAlphabet\mathsf{bold}\zf@enc\g_fontspec_mathsf_tl\bfdefault\updefault
  \SetMathAlphabet\mathtt{bold}\zf@enc\g_fontspec_mathtt_tl\bfdefault\updefault
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_maybe_setup_maths:}
% We're a little less sophisticated about not executing the maths setup if various other maths font packages are loaded. This list is based on the wonderful `\LaTeX Font Catalogue': \url{http://www.tug.dk/FontCatalogue/mathfonts.html}. I'm sure there are more I've missed. Do the \TeX\ Gyre fonts have maths support yet?
%
% Untested: would |\unless\ifnum\Gamma=28672\relax\bool_set_false:N \g_fontspec_math_bool\fi| be a better test?
% This needs more cooperation with euler and lucida, I think.
%    \begin{macrocode}
\cs_new:Nn \fontspec_maybe_setup_maths: {
  \@ifpackageloaded{anttor}{
    \ifx\define@antt@mathversions a\bool_set_false:N \g_fontspec_math_bool\fi}{}
  \@ifpackageloaded{arev}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{eulervm}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{mathdesign}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{concmath}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{cmbright}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{mathesf}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{gfsartemisia}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{gfsneohellenic}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{iwona}{
    \ifx\define@iwona@mathversions a\bool_set_false:N \g_fontspec_math_bool\fi}{}
  \@ifpackageloaded{kpfonts}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{kmath}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{kurier}{
    \ifx\define@kurier@mathversions a\bool_set_false:N \g_fontspec_math_bool\fi}{}
  \@ifpackageloaded{fouriernc}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{fourier}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{mathpazo}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{mathptmx}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{MinionPro}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{unicode-math}{\bool_set_false:N \g_fontspec_math_bool}{}
  \@ifpackageloaded{breqn}{\bool_set_false:N \g_fontspec_math_bool}{}
  \bool_if:NT \g_fontspec_math_bool {
    \fontspec_info:n {setup-math}
    \fontspec_setup_maths:
  }
}
\AtBeginDocument{\fontspec_maybe_setup_maths:}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Finishing up}
% Now we just want to set up loading the \texttt{.cfg} file, if it exists.
%    \begin{macrocode}
\bool_if:NT \g_fontspec_cfg_bool {
  \InputIfFileExists{fontspec.cfg}
    {}
    {\typeout{No~ fontspec.cfg~ file~ found;~ no~ configuration~ loaded.}}
}
%    \end{macrocode}
%
% The end! Thanks for coming.
%
% \iffalse
%</fontspec>
%<*lua>
% \fi
%
% \clearpage
% \part{fontspec.lua}
%
% First we define some metadata.
%    \begin{macrocode}
fontspec          = { }

fontspec.module   = {
    name          = "fontspec",
    version       = 2.0,
    date          = "2009/12/04",
    description   = "Advanced font selection for LuaLaTeX.",
    author        = "Khaled Hosny",
    copyright     = "Khaled Hosny",
    license       = "LPPL"
}

luatexbase.provides_module(fontspec.module)

%    \end{macrocode}
% Some utility functions
%    \begin{macrocode}

utf = unicode.utf8

function fontspec.log    (...) luatexbase.module_log    (fontspec.module.name, string.format(...)) end
function fontspec.warning(...) luatexbase.module_warning(fontspec.module.name, string.format(...)) end
function fontspec.error  (...) luatexbase.module_error  (fontspec.module.name, string.format(...)) end

function fontspec.sprint (...) tex.sprint(luatexbase.catcodetables['latex-package'], ...) end

%    \end{macrocode}
% The following functions check for exsitence of certain script, language or
% feature in a given font.
%    \begin{macrocode}

local function check_script(id, script)
    local s = string.lower(script)
    if id and id > 0 then
        local otfdata = fonts.ids[id].shared.otfdata
        if otfdata then
            local features = otfdata.luatex.features
            for i,_ in pairs(features) do
                for j,_ in pairs(features[i]) do
                    if features[i][j][s] then
                        fontspec.log("script '%s' exists in font '%s'",
                                      script, fonts.ids[id].fullname)
                        return true
                    end
                end
            end
        end
    end
end

local function check_language(id, language, script)
    local s = string.lower(script)
    local l = string.lower(language)
    if id and id > 0 then
        local otfdata = fonts.ids[id].shared.otfdata
        if otfdata then
            local features = otfdata.luatex.features
            for i,_ in pairs(features) do
                for j,_ in pairs(features[i]) do
                    if features[i][j][s] and features[i][j][s][l] then
                        fontspec.log("language '%s' for script '%s' exists in font '%s'",
                                      language, script, fonts.ids[id].fullname)
                        return true
                    end
                end
            end
        end
    end
end

local function check_feature(id, feature, language, script)
    local s = string.lower(script)
    local l = string.lower(language)
    local f = string.lower(feature:gsub("^[+-]", ""))
    if id and id > 0 then
        local otfdata = fonts.ids[id].shared.otfdata
        if otfdata then
            local features = otfdata.luatex.features
            for i,_ in pairs(features) do
                if features[i][f] and features[i][f][s] then
                    if features[i][f][s][l] == true then
                        fontspec.log("feature '%s' for language '%s' and script '%s' exists in font '%s'",
                                      feature, language, script, fonts.ids[id].fullname)
                        return true
                    end
                end
            end
        end
    end
end

%    \end{macrocode}
% The following are the function that get called from \TeX\ end.
%    \begin{macrocode}

local function tempswatrue()  fontspec.sprint([[\@tempswatrue]])  end
local function tempswafalse() fontspec.sprint([[\@tempswafalse]]) end

function fontspec.check_ot_script(fnt, script)
    if check_script(font.id(fnt), script) then
        tempswatrue()
    else
        tempswafalse()
    end
end

function fontspec.check_ot_lang(fnt, lang, script)
    if check_language(font.id(fnt), lang, script) then
        tempswatrue()
    else
        tempswafalse()
    end
end

function fontspec.check_ot_feat(fnt, feat, lang, script)
    for _, f in ipairs { "+trep", "+tlig", "+anum" } do
        if feat == f then
            tempswatrue()
            return
        end
    end
    if check_feature(font.id(fnt), feat, lang, script) then
        tempswatrue()
    else
        tempswafalse()
    end
end

%    \end{macrocode}
%
% \iffalse
%</lua>
% \fi
%
% \clearpage
% \part{fontspec-patches.sty}
%
% \iffalse
%<*patches>
% \fi
%
%    \begin{macrocode}
\ExplSyntaxOn
%    \end{macrocode}
%
% \subsection{Unicode footnote symbols}
%    \begin{macrocode}
\RequirePackage{fixltx2e}[2006/03/24]
%    \end{macrocode}
% \subsection{Emph}
%
% \begin{macro}{\em}
% \begin{macro}{\emph}
% \begin{macro}{\emshape}
% \begin{macro}{\eminnershape}
% Redefinition of |{\em ...}| and |\emph{...}| to use \textsc{nfss} info to detect when the inner shape should be used.
%    \begin{macrocode}
\DeclareRobustCommand \em {
  \@nomath\em
  \str_if_eq:xxTF \f@shape \itdefault \eminnershape
  {
    \str_if_eq:xxTF \f@shape \sldefault \eminnershape \emshape
  }
}
\DeclareTextFontCommand{\emph}{\em}
\cs_set_eq:NN \emshape \itshape
\cs_set_eq:NN \eminnershape \upshape
%    \end{macrocode}
% \end{macro} \end{macro}
% \end{macro} \end{macro}
%
% \subsection{\cmd\-}
%
% \begin{macro}{\-}
% This macro is courtesy of Frank Mittelbach and the \LaTeXe\ source code.
%    \begin{macrocode}
\DeclareRobustCommand{\-}{%
  \discretionary{%
    \char\ifnum\hyphenchar\font<\z@
           \xlx@defaulthyphenchar
         \else
           \hyphenchar\font
         \fi}{}{}}
\def\xlx@defaulthyphenchar{`\-}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Verbatims}
%
% Many thanks to Apostolos Syropoulos for discovering this problem and writing the  redefinion of \LaTeX's |verbatim| environment and \cs{verb*} command.
%
% \begin{macro}{\fontspec_visible_space:}
% Print \unichar{2434}{Open box}, which is used to visibly display a space character.
%    \begin{macrocode}
\cs_new:Npn \fontspec_visible_space: {
  \font_glyph_if_exist:NnTF \font {"2423}
    {\char"2423\relax}
    {\fontspec_visible_space_fallback:}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_visible_space:@fallback}
% If the current font doesn't have \unichar{2434}{Open box}, use Latin Modern Mono instead.
%    \begin{macrocode}
\cs_new:Npn \fontspec_visible_space_fallback: {
  {
    \usefont{\zf@enc}{lmtt}{\f@series}{\f@shape}
    \textvisiblespace
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_print_visible_spaces:}
% Helper macro to turn spaces (\verb|^^20|) active and print visible space instead.
%    \begin{macrocode}
\group_begin:
\char_make_active:n{"20}%
\cs_gset:Npn\fontspec_print_visible_spaces:{%
\char_make_active:n{"20}%
\cs_set_eq:NN^^20\fontspec_visible_space:%
}%
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\verb}
% \begin{macro}{\verb*}
% Redefine \cmd\verb\ to use \cmd\fontspec_print_visible_spaces:.
%    \begin{macrocode}
\def\verb{
  \relax\ifmmode\hbox\else\leavevmode\null\fi
  \bgroup
    \verb@eol@error \let\do\@makeother \dospecials
    \verbatim@font\@noligs
    \@ifstar\@@sverb\@verb
}
\def\@@sverb{\fontspec_print_visible_spaces:\@sverb}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% It's better to put small things into \cmd\AtBeginDocument, so here we go:
%    \begin{macrocode}
\AtBeginDocument{
  \fontspec_patch_verbatim:
  \fontspec_patch_moreverb:
  \fontspec_patch_fancyvrb:
  \fontspec_patch_listings:
}
%    \end{macrocode}
%
% \begin{environment}{verbatim*}
% With the \pkg{verbatim} package.
%    \begin{macrocode}
\cs_set:Npn \fontspec_patch_verbatim: {
  \@ifpackageloaded{verbatim}{
    \cs_set:cpn {verbatim*} {
      \group_begin: \@verbatim \fontspec_print_visible_spaces: \verbatim@start
    }
  }{
%    \end{macrocode}
% This is for vanilla \LaTeX.
%    \begin{macrocode}
    \cs_set:cpn {verbatim*} {
      \@verbatim \fontspec_print_visible_spaces: \@sxverbatim
    }
  }
}
%    \end{macrocode}
% \end{environment}
%
% \begin{environment}{listingcont*}
% This is for \pkg{moreverb}.
% The main |listing*| environment inherits this definition.
%    \begin{macrocode}
\cs_set:Npn \fontspec_patch_moreverb: {
  \@ifpackageloaded{moreverb}{
    \cs_set:cpn {listingcont*} {
      \cs_set:Npn \verbatim@processline {
        \thelisting@line \global\advance\listing@line\c_one
        \the\verbatim@line\par
      }
      \@verbatim \fontspec_print_visible_spaces: \verbatim@start
    }
  }{}
}
%    \end{macrocode}
% \end{environment}
%
% \pkg{listings} and \pkg{fancvrb} make things nice and easy:
%    \begin{macrocode}
\cs_set:Npn \fontspec_patch_fancyvrb: {
  \@ifpackageloaded{fancyvrb}{
    \cs_set_eq:NN \FancyVerbSpace \fontspec_visible_space:
  }{}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set:Npn \fontspec_patch_listings: {
  \@ifpackageloaded{listings}{
    \cs_set_eq:NN \lst@visiblespace \fontspec_visible_space:
  }{}
}
%    \end{macrocode}
%
% \iffalse
%</patches>
% \fi
%
% \clearpage
% \part{fontspec.cfg}
%
% \iffalse
%<*cfg>
% \fi
%
%    \begin{macrocode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% FOR BACKWARDS COMPATIBILITY WITH PREVIOUS VERSIONS %%%

% Please note that most of the entries here from fontspec v1.x are
% no longer present. Please advise of any serious problems this causes.

\aliasfontfeatureoption{Ligatures}{Historic}{Historical}
\let\newfontinstance\newfontfamily

%    \end{macrocode}
%
% \iffalse
%</cfg>
% \fi
%
% \clearpage
% \PrintChanges
%
% \clearpage
% \setcounter{IndexColumns}{2}
% \PrintIndex
%
% \Finale
%
% \iffalse
%<*example>
%
%    \begin{macrocode}
\documentclass{article}

\usepackage{fontspec}

\setmainfont[Ligatures=TeX]{TeX Gyre Pagella}
\setsansfont[Ligatures=TeX,Scale=MatchLowercase]{TeX Gyre Heros}
\setmonofont[Scale=MatchLowercase]{Inconsolata}

\begin{document}
\pagestyle{empty}

\section*{The basics of the \textsf{fontspec} package}

The \textsf{fontspec} package enables automatic font selection
for \LaTeX{} documents typeset with Xe\TeX{} or \LuaTeX.
The basic command is

{\centering \verb|\fontspec[font features]{font display name}|.\par}

The default, sans serif, and typewriter fonts may be set with the
\verb|\setmainfont|, \verb|\setsansfont| and \verb|\setmonofont|
commands, respectively, as shown in the preamble. They take the
same syntax as the \verb|\fontspec| package. All expected font
shapes are available:

\begin{center}
  {\itshape Italics and \scshape small caps\dots}\\
  {\sffamily\bfseries Bold sans serif and \itshape bold italic sans serif\dots}
\end{center}

Text fonts in maths mode are also changed (e.g., notice the cosine function in
`$\cos(n\pi)=\pm 1$') but only if the roman and sans serif fonts are set in
the preamble; \verb|\setmainfont| will not affect these maths mode fonts when
called mid-document.
Maths symbols themselves are not affected.

Notice the font features used to load the default fonts in the preamble.
The first, \verb|Ligatures=TeX|, enables regular \TeX{} ligatures like
\verb|``---''| for ``---''.
The second, \verb|Scale=MatchLowercase|, automatically scales the fonts to
the same x-height.

Please see the complete \textsf{fontspec} documentation for further
information.

\end{document}
%    \end{macrocode}
%
%</example>
%<*testsuite>
%
%    \begin{macrocode}
\documentclass{article}
\usepackage{fontspec,fancyvrb,geometry,graphicx,calc,multicol}
\geometry{margin=2cm,a4paper}
\setmainfont[Ligatures=TeX]{TeX Gyre Pagella}
\setmonofont{Consolas}

\newcommand\meta[1]{$\langle$\emph{#1}$\rangle$}

\newcommand\TEST[1]{%
  \section{Test #1}
  \begin{minipage}{0.5\textwidth}
  \VerbatimInput{testsuite/#1.ltx}
  \end{minipage}
  \hfill
  \begin{minipage}{8cm+4pt}
    \fboxsep=1pt
    \fboxrule=1pt
    \fbox{\insertpdf#1\END}
  \end{minipage}
}

\def\insertpdf#1#2\END{%
  \ifnum`#1=70\relax
    \includegraphics[width=8cm]{testsuite/#1#2.Lsafe.pdf}%
  \else
    \includegraphics[width=8cm]{testsuite/#1#2.safe.pdf}%
  \fi
}

\newcommand\codeline[1]{\par{\centering#1\par}\par\noindent\ignorespaces}

\pagestyle{empty}
\begin{document}
\title{The \textsf{fontspec} test suite}
\author{Will Robertson}
\date{Compiled: \today}
\maketitle
\thispagestyle{empty}

\section*{Preamble}

\begin{multicols}{2}\noindent
The examples shown in the remainder of the document are generated directly from the code shown alongside.
As well as being good minimal examples, these tests are useful to ensure that changes to \textsf{fontspec} don't affect old behaviour.

When the test suite is run, the new output is compared pixel by pixel with that shown here and warnings produced if the outputs are not identical (within a small tolerance to account for rounding errors).

Tests with a name that begins with `\textit X' are processed with \texttt{xelatex} only; `\textit L' with \texttt{lualatex}; and `\textit F' with both.
In the latter case, the output from both engines is compared with each other, ensuring that the package is consistent cross-platform.

To generate tests yourself, write a new file in the \texttt{testsuite/} folder with filename
\codeline{\meta{F,L,X}\meta{num}\meta{letter}\texttt{.ltx}}
according to the naming scheme above and the following numbering scheme. If you are writing a new test entirely, increment the \meta{num}; if you are writing a variation on an old test, increment the \meta{letter}. No need to be too fussy, though.

After writing the new test, run
\codeline{\texttt{make initest}}
This will generate the reference output (\texttt{*.safe.pdf}) from which to check all future tests.
After any changes have been made to \textsf{fontspec}, the entire test suite is compiled with \codeline{\texttt{make check}}
If you want to run just a single test, use
\codeline{\texttt{make }\meta{testname}}
(but this syntax \emph{may} be fragile and need to be changed in the future).
\end{multicols}

\input{testsuite/testsuite-listing.tex}

\end{document}
%    \end{macrocode}
%</testsuite>
%
%<*doc-style>
%    \begin{macrocode}
\ProvidesPackage{fontspec-style}

\usepackage{booktabs,calc,caption,color,enumitem,fancyvrb,hologo,graphicx,ifthen,url,varioref,varwidth,microtype,tocloft}

% ToC formatting:
\setlength\cftsubsecnumwidth{1.4\cftsubsecnumwidth}
\def\@cfttocstart{\begin{multicols}{2}}
\def\@cfttocfinish{\end{multicols}}

\fvset{gobble=2}

\captionsetup[table]{position=above}
\captionsetup[figure]{position=above}

\newcommand\XeTeX{\hologo{XeTeX}}
\newcommand\XeLaTeX{\hologo{XeLaTeX}}
\newcommand\LuaTeX{\hologo{LuaTeX}}
\newcommand\LuaLaTeX{\hologo{LuaLaTeX}}
\usepackage{tgpagella,eulervm}
\usepackage{inconsolata}
\usepackage[
  bookmarks=true,
  colorlinks=true,
  linkcolor=niceblue,
  urlcolor=niceblue,
  citecolor=niceblue,
  pdftitle={The fontspec package},
  pdfsubject={Advanced font selection for XeLaTeX/LuaLaTeX},
  pdfauthor={Will Robertson},
  pdfkeywords={xetex, xelatex, luatex, lualatex, unicode, opentype, aat}
  ]{hyperref}

%% ToC
\def\@dotsep{1000}
\setcounter{tocdepth}{2}
\setlength\columnseprule{0.4pt}
\renewcommand\tableofcontents{\relax
  \begin{multicols}{2}[\section*{\contentsname}]\relax
    \@starttoc{toc}\relax
  \end{multicols}}

%% Index
\setcounter{IndexColumns}{2}
\renewenvironment{theglossary}
  {\small\list{}{}
     \item\relax
     \glossary@prologue\GlossaryParms
     \let\item\@idxitem \ignorespaces
     \def\pfill{\hspace*{\fill}}}
  {\endlist}

%% varioref definitions:
\labelformat{table}{Table~#1}
\labelformat{section}{Section~#1}
\labelformat{subsection}{Section~#1}

\definecolor{niceblue}{rgb}{0.1,0.2,0.8}

\newsavebox\X
\newsavebox\Y

\newcounter{example}

\newcommand\exref[1]{Example~\ref{ex:#1}}
\newcommand\Exref[1]{Example~\ref{ex:#1}}

\newenvironment{Xexample}[3][]
  {\VerbatimEnvironment\begin{Fexample}[#1]{#2}{#3}{X}}
  {\end{Fexample}}

\newenvironment{Lexample}[3][]
  {\VerbatimEnvironment\begin{Fexample}[#1]{#2}{#3}{L}}
  {\end{Fexample}}



\newenvironment{Fexample}[4][]
  {%
    \def\options{#1}%
    \def\filename{#2}%
    \def\captiontext{#3}%
    \def\prefix{#4}
    \refstepcounter{example}%
    \label{ex:\filename}%
    \IfFileExists{doc/\theexample-\prefix-\filename.tex}{}{%
      \immediate\write18{cd doc && rm -f \theexample-* ;}%
    }%
    \VerbatimEnvironment
    \begin{VerbatimOut}{doc/\theexample-\prefix-\filename.tex}}
% text in the environment
  {\end{VerbatimOut}
    \begin{figure}
      \setlength\parindent{0pt}%
      \edef\@tempa{[gobble=0,fontsize=\noexpand\small,\options]}%
      \savebox\X{%
                  \expandafter\BVerbatimInput
                  \@tempa{doc/\theexample-\prefix-\filename.tex}%
                }%
      \IfFileExists{doc/\theexample-\prefix-\filename.pdf}{}
         {%
           \edef\1{%
             cd doc; \csname prog@\prefix\endcsname
             "%
             \unexpanded{%
               \documentclass{article}%
               \usepackage{booktabs,ifthen,graphicx,xcolor,varwidth}
               \usepackage[active,tightpage]{preview}%
               \usepackage{fontspec}%
               \defaultfontfeatures{Ligatures=TeX} \begin{document}\begin{preview}\begin{varwidth}{0.7\linewidth}\input} \theexample-\prefix-\filename.tex
             \unexpanded{\end{varwidth}\end{preview}\end{document}}
             "
           }%
           \immediate\write18{
              mkdir -p doc;
              cp -a fontspec.dtx doc/;
              cd doc;
              tex fontspec.dtx > /dev/null ;
           }
           \immediate\write18{\unexpanded\expandafter{\1}}%
         }%
      \savebox\Y{%
      \IfFileExists{doc/\theexample-\prefix-\filename.pdf}
          {\includegraphics{doc/\theexample-\prefix-\filename.pdf}}
          {Graphic not generated.}%
      }
      % TYPESETTING
      \rule[0.5\baselineskip]{\columnwidth}{1pt}%
      \vspace{-1.2ex}%
      \def\@tempa{\small\textsf{Example~\theexample:~}}%
      \settowidth\@tempdima{\@tempa\captiontext}%
      \par
      \ifdim\@tempdima>\linewidth
        \settowidth\@tempdima{\@tempa}%
        \@tempa\parbox[t]{\linewidth-\@tempdima}{\small\captiontext}%
        \vspace{0.4\baselineskip}%
      \else
        \parbox{\linewidth}{\centering\@tempa~\captiontext}%
      \fi
      \par\rule[0.4\baselineskip]{\columnwidth}{0.4pt}\par
      \ifdim\dimexpr\wd\X+\wd\Y>\linewidth\relax
        \null\hfill\makebox[0pt][r]{\usebox\Y}\usebox\X
      \else
        \hfill\usebox\Y\hfill\usebox\X
      \fi
      \par\rule[0.5\baselineskip]{\columnwidth}{1pt}
    \end{figure}
}

\def\prog@X{xelatex
               -output-driver=xdv2pdf\space
               -jobname=\theexample-X-\filename\space}

\def\prog@L{lualatex
               -jobname=\theexample-L-\filename\space}

%%%%%%%%%%%%%%%%%%%%%%

\newcommand*\setexsize[1]{\let\examplesize#1}
\newcommand*\setverbwidth[1]{\def\auxwidth{#1}}

%% Various labelling commands:
\newcommand*\name[1]{{#1}}
\newcommand*\pkg[1]{\textsf{#1}}
\newcommand*\opt[1]{\texttt{#1}}
\newcommand*\feat[1]{\texttt{#1}}

\let\latin\textit
\def\eg{\latin{e.g.}}
\def\ie{\latin{i.e.}}
\def\Eg{\latin{E.g.}}
\def\Ie{\latin{I.e.}}
\def\etc{\@ifnextchar.{\latin{etc}}{\latin{etc.}\@}}

\newcommand\note[1]{\unskip\footnote{#1}}

\def\MacOSX{Mac~OS~X}
\def\AAT{\textsc{aat}}
\def\ATSUI{\textsc{atsui}}
\def\ICU{\textsc{icu}}

%% (La)TeX font-related declarations:
\linespread{1.05}      % Pagella needs more space between lines
\frenchspacing         % Remove ugly extra space after punctuation

\makeatletter
\newcounter{argument}
\g@addto@macro\endmacro{\setcounter{argument}{0}}
\newcommand*\darg[1]{%
  \stepcounter{argument}%
  \noindent{\ttfamily\char`\#\theargument~:~}#1\par}
\newcommand*\doarg[1]{%
  \stepcounter{argument}%
  \noindent{\ttfamily\makebox[0pt][r]{[}\char`\#\theargument]:~}#1\par}
\makeatother

\newcommand\unichar[2]{\textsc{\MakeLowercase{u+#1: #2}}}

\newcommand\cmdbox[1]{%
  \smallskip\par\noindent
  \fbox{\begin{varwidth}{\linewidth}
    #1%
  \end{varwidth}}%
  \smallskip
}
\def\CMD#1{\texttt{\null#1\unskip}}

\usepackage{xparse}
\NewDocumentCommand \otf {somm} {%
  \IfBooleanTF #1
  {%
    \gdef\NOTE{\par\smallskip {$\ast$ \footnotesize This feature is activated by default.}}%
    \IfNoValueTF {#2} {\gdef\offname{No#3}}{\gdef\offname{#2}}%
    \featname&#3&$\ast$&\texttt{#4}\\
    \featname&\offname&&\texttt{#4}~~{\footnotesize(\textit{deactivate})}\\
  }
  {\featname&#3&&\texttt{#4}\\}%
}
\newenvironment{features}[1]{%
  \def\NOTE{}
  \def\thisfeatname{#1}%
  \def\featname{\thisfeatname~~\texttt=~~\null\gdef\featname{}}%
  \begin{table}
    \caption{Options for the OpenType font feature `\thisfeatname'.}
    \edef\@tempa{\noexpand\label{feat:\thisfeatname}}\@tempa
    \centering
    \begin{tabular}{@{}l@{}l@{\hspace{0.5\tabcolsep}}l@{\hspace{0.5\tabcolsep}}l@{}}
    \toprule
    Feature & Option && Tag \\
    \midrule
}{
    \bottomrule
    \end{tabular}
    \NOTE
  \end{table}
}

%%%%%%%%%%%

\def \MakePrivateLetters {%
  \catcode `\@ = 11
  \catcode `\_ = 11
  \catcode `\: = 11
}

%% for LaTeX3 csnames
\catcode `\_= 11

\renewcommand\partname{Part}

%    \end{macrocode}
%</doc-style>
% \fi
\endinput
